<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AATM - Amazing Automatic Torrent Maker</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M25 15 L25 55 Q25 75 45 75 L45 85 Q15 85 15 55 L15 15 Z' fill='%231a1a4e'/%3E%3Cpath d='M75 15 L75 55 Q75 75 55 75 L55 85 Q85 85 85 55 L85 15 Z' fill='%231a1a4e'/%3E%3Crect x='15' y='10' width='15' height='15' rx='2' fill='%23c0c0c0'/%3E%3Crect x='70' y='10' width='15' height='15' rx='2' fill='%23c0c0c0'/%3E%3Cellipse cx='50' cy='50' rx='8' ry='12' fill='%2300d9ff' opacity='0.6'/%3E%3C/svg%3E">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --bg-hover: #1f2847;
            --accent: #00d9ff;
            --accent-dim: #0099b3;
            --text-primary: #eee;
            --text-secondary: #888;
            --text-muted: #555;
            --success: #0f5132;
            --success-text: #75b798;
            --warning: #664d03;
            --warning-text: #ffda6a;
            --danger: #842029;
            --danger-text: #ea868f;
            --border: #2a2a4a;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }
        .app-container { display: flex; height: 100vh; }
        .sidebar {
            width: 220px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header { padding: 1.5rem 1rem; border-bottom: 1px solid var(--border); }
        .sidebar-header h1 { color: var(--accent); font-size: 1.3rem; font-weight: 600; }
        .sidebar-header .subtitle { color: var(--text-secondary); font-size: 0.75rem; }
        .nav-menu { flex: 1; padding: 1rem 0; }
        .nav-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1.25rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .nav-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .nav-item.active { background: var(--bg-tertiary); color: var(--accent); border-left-color: var(--accent); }
        .nav-item svg { width: 20px; height: 20px; margin-right: 0.75rem; }
        .api-status { padding: 1rem; border-top: 1px solid var(--border); font-size: 0.8rem; }
        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 0.5rem; }
        .status-indicator.online { background: var(--success-text); box-shadow: 0 0 6px var(--success-text); }
        .status-indicator.offline { background: var(--danger-text); }
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .header {
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header h2 { color: var(--text-primary); font-size: 1.2rem; font-weight: 500; }
        .content-area { flex: 1; overflow: auto; padding: 1.5rem; }
        .explorer-container { display: grid; grid-template-columns: 1fr 400px; gap: 1.5rem; height: 100%; }
        .file-browser { background: var(--bg-secondary); border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        .breadcrumb {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .breadcrumb-item { color: var(--text-secondary); cursor: pointer; font-size: 0.9rem; }
        .breadcrumb-item:hover { color: var(--accent); }
        .breadcrumb-item.current { color: var(--text-primary); }
        .breadcrumb-separator { color: var(--text-muted); }
        .file-list { flex: 1; overflow-y: auto; }
        .file-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .file-item:hover { background: var(--bg-hover); }
        .file-item.selected { background: var(--bg-tertiary); border-left: 3px solid var(--accent); }
        .file-item.processed { opacity: 0.5; }
        .file-icon { width: 24px; height: 24px; margin-right: 0.75rem; color: var(--text-secondary); }
        .file-icon.folder { color: var(--warning-text); }
        .file-icon.video { color: var(--accent); }
        .file-icon.ebook { color: #a78bfa; }
        .file-icon.game { color: #10b981; }
        .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .file-size { color: var(--text-secondary); font-size: 0.85rem; margin-left: 1rem; }
        .processed-badge { background: var(--success); color: var(--success-text); font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 3px; margin-left: 0.5rem; }
        .details-panel { background: var(--bg-secondary); border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        .details-header { padding: 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border); }
        .details-header h3 { font-size: 1rem; font-weight: 500; }
        .details-content { flex: 1; overflow-y: auto; padding: 1rem; }
        .detail-section { margin-bottom: 1.5rem; }
        .detail-section h4 { color: var(--accent); font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; }
        .mediainfo-output { background: var(--bg-primary); border-radius: 4px; padding: 1rem; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.75rem; white-space: pre-wrap; max-height: 400px; overflow-y: auto; color: var(--text-secondary); }
        .detail-row { display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid var(--border); }
        .detail-row:last-child { border-bottom: none; }
        .detail-label { color: var(--text-secondary); }
        .detail-value { color: var(--text-primary); font-weight: 500; }
        .action-buttons { padding: 1rem; border-top: 1px solid var(--border); display: flex; gap: 0.75rem; }
        .btn { padding: 0.6rem 1rem; border: none; border-radius: 6px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
        .btn svg { width: 16px; height: 16px; }
        .btn-primary { background: var(--accent); color: var(--bg-primary); font-weight: 500; }
        .btn-primary:hover { background: var(--accent-dim); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--bg-hover); }
        .btn-danger { background: var(--danger); color: var(--danger-text); }
        .btn-success { background: var(--success); color: var(--success-text); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-sm { padding: 0.4rem 0.75rem; font-size: 0.8rem; }
        .btn-full { width: 100%; justify-content: center; }
        .workflow-container { max-width: 1000px; margin: 0 auto; }
        .workflow-steps { display: flex; margin-bottom: 2rem; padding: 0 1rem; }
        .workflow-step { flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; }
        .workflow-step::after { content: ''; position: absolute; top: 15px; left: 50%; width: 100%; height: 2px; background: var(--border); }
        .workflow-step:last-child::after { display: none; }
        .step-number { width: 30px; height: 30px; border-radius: 50%; background: var(--bg-tertiary); border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-size: 0.85rem; font-weight: 600; z-index: 1; transition: all 0.3s; }
        .workflow-step.active .step-number { background: var(--accent); border-color: var(--accent); color: var(--bg-primary); }
        .workflow-step.completed .step-number { background: var(--success); border-color: var(--success-text); color: var(--success-text); }
        .step-label { margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary); }
        .workflow-step.active .step-label { color: var(--accent); }
        .workflow-content { background: var(--bg-secondary); border-radius: 8px; padding: 1.5rem; }
        .workflow-title { font-size: 1.1rem; margin-bottom: 1rem; }
        .workflow-actions { display: flex; justify-content: space-between; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); }
        .form-group { margin-bottom: 1rem; }
        .form-group label { display: block; color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem; }
        .form-control { width: 100%; padding: 0.6rem 0.75rem; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 0.9rem; }
        .form-control:focus { outline: none; border-color: var(--accent); }
        textarea.form-control { min-height: 150px; resize: vertical; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; }
        .form-check { display: flex; align-items: center; gap: 0.5rem; }
        .form-check input { width: 16px; height: 16px; accent-color: var(--accent); }
        .settings-container { max-width: 700px; margin: 0 auto; }
        .settings-section { background: var(--bg-secondary); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; }
        .settings-section h3 { color: var(--accent); font-size: 1rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border); }
        .history-container { max-width: 800px; margin: 0 auto; }
        .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        .history-list { background: var(--bg-secondary); border-radius: 8px; }
        .history-item { padding: 1rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
        .history-item:last-child { border-bottom: none; }
        .history-path { font-family: monospace; font-size: 0.85rem; color: var(--text-secondary); }
        .alert { padding: 1rem; border-radius: 6px; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem; }
        .alert-success { background: var(--success); color: var(--success-text); }
        .alert-danger { background: var(--danger); color: var(--danger-text); }
        .alert-warning { background: var(--warning); color: var(--warning-text); }
        .loading { display: flex; align-items: center; justify-content: center; padding: 2rem; color: var(--text-secondary); }
        .spinner { width: 24px; height: 24px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 0.75rem; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .empty-state { text-align: center; padding: 3rem; color: var(--text-secondary); }
        .empty-state svg { width: 64px; height: 64px; margin-bottom: 1rem; opacity: 0.5; }
        .hidden { display: none !important; }
        .toast-container { position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 1000; }
        .toast { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 1rem 1.25rem; margin-top: 0.75rem; display: flex; align-items: center; gap: 0.75rem; animation: slideIn 0.3s ease; max-width: 400px; }
        .toast.success { border-color: var(--success-text); }
        .toast.error { border-color: var(--danger-text); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        @media (max-width: 1024px) { .explorer-container { grid-template-columns: 1fr; } .details-panel { max-height: 400px; } }
        @media (max-width: 768px) { .sidebar { width: 60px; } .sidebar-header h1, .sidebar-header .subtitle, .nav-item span, .api-status span { display: none; } .nav-item { justify-content: center; padding: 1rem; } .nav-item svg { margin-right: 0; } }

        /* New styles for TMDB and tags */
        .tag { display: inline-block; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; margin: 0.15rem; }
        .tag.resolution { color: #10b981; border-color: #10b981; }
        .tag.codec { color: #f472b6; border-color: #f472b6; }
        .tag.audio { color: #fb923c; border-color: #fb923c; }
        .tag.language { color: #ef4444; border-color: #ef4444; }
        .tag.source { color: #a78bfa; border-color: #a78bfa; }
        .tag.hdr { color: #22d3ee; border-color: #22d3ee; }
        .tag.year { color: #60a5fa; border-color: #60a5fa; }
        .tag.group { color: #9ca3af; border-color: #9ca3af; }
        .tmdb-results { max-height: 300px; overflow-y: auto; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; margin-top: 0.5rem; }
        .tmdb-item { display: flex; gap: 1rem; padding: 0.75rem; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
        .tmdb-item:hover { background: var(--bg-hover); }
        .tmdb-item:last-child { border-bottom: none; }
        .tmdb-item img { width: 50px; height: 75px; object-fit: cover; border-radius: 4px; background: var(--bg-tertiary); }
        .tmdb-item-info { flex: 1; }
        .tmdb-item-title { font-weight: 500; color: var(--text-primary); }
        .tmdb-item-year { font-size: 0.8rem; color: var(--text-secondary); }
        .tmdb-item-overview { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .tmdb-selected { display: flex; gap: 1rem; padding: 1rem; background: var(--bg-tertiary); border: 1px solid var(--success-text); border-radius: 6px; margin-top: 0.5rem; }
        .tmdb-selected img { width: 80px; height: 120px; object-fit: cover; border-radius: 4px; }
        .tmdb-selected-info { flex: 1; }
        .tmdb-selected-title { font-weight: 600; color: var(--text-primary); font-size: 1.1rem; }
        .tmdb-selected-meta { font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem; }
        .tmdb-selected-overview { font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem; }
        .media-type-selector { display: flex; gap: 1rem; margin-bottom: 1rem; }
        .media-type-btn { flex: 1; padding: 1rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s; }
        .media-type-btn:hover { border-color: var(--accent); }
        .media-type-btn.active { border-color: var(--accent); background: var(--bg-hover); }
        .media-type-btn svg { width: 32px; height: 32px; margin-bottom: 0.5rem; color: var(--text-secondary); }
        .media-type-btn.active svg { color: var(--accent); }
        .media-type-btn span { display: block; font-size: 0.85rem; color: var(--text-secondary); }
        .media-type-btn.active span { color: var(--text-primary); }
        .release-tags { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-top: 0.5rem; }
        .search-row { display: flex; gap: 0.5rem; }
        .search-row input { flex: 1; }
        /* Preview step 5 */
        .preview-section { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; margin-bottom: 1rem; }
        .preview-section h4 { color: var(--accent); margin-bottom: 0.75rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .preview-section .form-control { width: 100%; }
        .preview-section textarea.form-control { min-height: 200px; font-family: monospace; font-size: 0.8rem; line-height: 1.4; }
        .tag-group { margin-bottom: 0.75rem; }
        .tag-group-title { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.35rem; font-weight: 500; }
        .tag-chips { display: flex; flex-wrap: wrap; gap: 0.35rem; }
        .tag-chip { display: inline-block; padding: 0.2rem 0.6rem; font-size: 0.75rem; border-radius: 12px; cursor: pointer; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); transition: all 0.15s; user-select: none; }
        .tag-chip:hover { border-color: var(--accent-dim); color: var(--text-primary); }
        .tag-chip.selected { background: var(--accent); color: #000; border-color: var(--accent); font-weight: 600; }
        .preview-category { display: inline-block; padding: 0.3rem 0.8rem; background: var(--bg-hover); border: 1px solid var(--accent-dim); border-radius: 6px; color: var(--accent); font-weight: 500; font-size: 0.85rem; }
        #previewLoading { text-align: center; padding: 2rem; }
        #previewContent { display: none; }
        .bbcode-tabs { display: flex; gap: 0; margin-bottom: -1px; }
        .bbcode-tab { padding: 0.4rem 1rem; font-size: 0.8rem; cursor: pointer; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-secondary); border-radius: 4px 4px 0 0; transition: all 0.15s; }
        .bbcode-tab.active { background: var(--bg-tertiary); color: var(--accent); border-bottom-color: var(--bg-tertiary); }
        .bbcode-tab-content { display: none; }
        .bbcode-tab-content.active { display: block; }
        .bbcode-render { background: var(--bg-primary); border: 1px solid var(--border); border-radius: 0 4px 4px 4px; padding: 1rem; min-height: 200px; font-size: 0.85rem; line-height: 1.7; word-break: break-word; }
        .bbcode-render img { max-width: 220px; border-radius: 4px; display: block; margin: 0.5rem auto; }
        .bbcode-render .bbcode-quote { border-left: 3px solid var(--accent-dim); padding: 0.5rem 0.75rem; margin: 0.5rem 0; color: var(--text-secondary); background: var(--bg-secondary); border-radius: 0 4px 4px 0; }
        .bbcode-render strong { font-weight: 700; }
        .bbcode-render em { font-style: italic; }
    </style>
</head>
<body>
    <div class="app-container">
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>AATM</h1>
                <p class="subtitle">Torrent Maker</p>
            </div>
            <div class="nav-menu">
                <div class="nav-item active" data-page="files">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
                    <span>Explorateur</span>
                </div>
                <div class="nav-item" data-page="create">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
                    <span>Creer Torrent</span>
                </div>
                <div class="nav-item" data-page="settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                    <span>Parametres</span>
                </div>
                <div class="nav-item" data-page="history">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                    <span>Historique</span>
                </div>
            </div>
            <div class="api-status">
                <span class="status-indicator online" id="statusIndicator"></span>
                <span id="statusText">API en ligne</span>
            </div>
        </nav>

        <main class="main-content">
            <header class="header">
                <h2 id="pageTitle">Explorateur de fichiers</h2>
                <div id="headerActions"></div>
            </header>

            <div class="content-area">
                <!-- Files Page -->
                <div id="page-files" class="page">
                    <div class="explorer-container">
                        <div class="file-browser">
                            <div style="display:flex;align-items:center;gap:1rem;margin-bottom:0.5rem;">
                                <div class="breadcrumb" id="breadcrumb" style="flex:1;margin-bottom:0;"><span class="breadcrumb-item current">/</span></div>
                                <button class="btn btn-primary btn-sm" id="btnCreateFromFolder" title="Creer un torrent de ce dossier">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                                    Torrent du dossier
                                </button>
                            </div>
                            <div class="file-list" id="fileList"><div class="loading"><div class="spinner"></div>Chargement...</div></div>
                        </div>
                        <div class="details-panel">
                            <div class="details-header"><h3 id="detailsTitle">Details</h3></div>
                            <div class="details-content" id="detailsContent">
                                <div class="empty-state">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                                    <p>Selectionnez un fichier pour voir ses details</p>
                                </div>
                            </div>
                            <div class="action-buttons" id="fileActions" style="display:none;">
                                <button class="btn btn-primary btn-full" id="btnStartWorkflow">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
                                    Creer un torrent
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Create Workflow Page -->
                <div id="page-create" class="page hidden">
                    <div class="workflow-container">
                        <div class="workflow-steps">
                            <div class="workflow-step active" data-step="1"><div class="step-number">1</div><div class="step-label">Type</div></div>
                            <div class="workflow-step" data-step="2"><div class="step-number">2</div><div class="step-label">TMDB</div></div>
                            <div class="workflow-step" data-step="3"><div class="step-number">3</div><div class="step-label">NFO</div></div>
                            <div class="workflow-step" data-step="4"><div class="step-number">4</div><div class="step-label">Torrent</div></div>
                            <div class="workflow-step" data-step="5"><div class="step-number">5</div><div class="step-label">Upload</div></div>
                        </div>

                        <!-- Step 1: Type Selection -->
                        <div class="workflow-content" id="step-1">
                            <h3 class="workflow-title">Selection du type de media</h3>
                            <div id="selectedSource"></div>
                            <div class="media-type-selector" id="mediaTypeSelector">
                                <div class="media-type-btn" data-type="movie">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg>
                                    <span>Film</span>
                                </div>
                                <div class="media-type-btn" data-type="episode">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>
                                    <span>Episode</span>
                                </div>
                                <div class="media-type-btn" data-type="season">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                                    <span>Saison</span>
                                </div>
                                <div class="media-type-btn" data-type="ebook">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
                                    <span>E-book</span>
                                </div>
                                <div class="media-type-btn" data-type="game">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12" rx="2"/><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><circle cx="17" cy="10" r="1"/><circle cx="15" cy="13" r="1"/></svg>
                                    <span>Jeu video</span>
                                </div>
                            </div>
                            <div class="detail-section" style="margin-top:1rem;">
                                <h4>Tags detectes</h4>
                                <div class="release-tags" id="releaseTags">-</div>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="navigateTo('files')">Choisir un fichier</button>
                                <button class="btn btn-primary" id="btnStep1Next" disabled>Suivant</button>
                            </div>
                        </div>

                        <!-- Step 2: Metadata Search (TMDB / Google Books / Steam) -->
                        <div class="workflow-content hidden" id="step-2">
                            <h3 class="workflow-title" id="step2Title">Identification</h3>
                            <div class="form-group">
                                <label id="step2Label">Rechercher</label>
                                <div class="search-row">
                                    <input type="text" class="form-control" id="metadataQuery" placeholder="Rechercher...">
                                    <button class="btn btn-primary" id="btnMetadataSearch">Rechercher</button>
                                </div>
                                <div id="metadataResults" class="tmdb-results hidden"></div>
                                <div id="metadataSelected" class="hidden"></div>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(1)">Precedent</button>
                                <button class="btn btn-primary" id="btnStep2Next" disabled>Suivant</button>
                            </div>
                        </div>

                        <!-- Step 3: NFO -->
                        <div class="workflow-content hidden" id="step-3">
                            <h3 class="workflow-title">MediaInfo et NFO</h3>
                            <div class="form-group">
                                <label>Apercu MediaInfo</label>
                                <div class="mediainfo-output" id="workflowMediainfo">Chargement...</div>
                            </div>
                            <div class="form-group">
                                <label>Contenu NFO (editable)</label>
                                <textarea class="form-control" id="nfoContent" placeholder="Le contenu MediaInfo sera copie ici..."></textarea>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(2)">Precedent</button>
                                <button class="btn btn-primary" onclick="goToStep(4)">Suivant</button>
                            </div>
                        </div>

                        <!-- Step 4: Torrent Config -->
                        <div class="workflow-content hidden" id="step-4">
                            <h3 class="workflow-title">Configuration du torrent</h3>
                            <div class="detail-section" style="margin-bottom: 1rem;">
                                <h4>Fichier</h4>
                                <div class="detail-row"><span class="detail-label">Nom actuel</span><span class="detail-value" id="currentFileName" style="word-break: break-all;">-</span></div>
                                <div class="detail-row" id="futureFileNameRow"><span class="detail-label">Nouveau nom</span><span class="detail-value" id="futureFileName" style="word-break: break-all; color: var(--accent);">-</span></div>
                            </div>
                            <div class="form-group">
                                <label>Nom du torrent</label>
                                <input type="text" class="form-control" id="torrentName" placeholder="Nom du fichier torrent">
                            </div>
                            <div class="form-group">
                                <label>Trackers (un par ligne)</label>
                                <textarea class="form-control" id="trackersInput" rows="4" placeholder="http://tracker.example.com/announce"></textarea>
                            </div>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="torrentPrivate" checked>
                                    <label for="torrentPrivate">Torrent prive</label>
                                </div>
                                <div class="form-check" style="margin-top: 0.5rem;">
                                    <input type="checkbox" id="renameFile" checked>
                                    <label for="renameFile">Renommer le fichier (MKV et hardlink)</label>
                                </div>
                            </div>
                            <div id="creationProgress" class="hidden">
                                <div class="loading"><div class="spinner"></div><span id="creationProgressText">Creation en cours...</span></div>
                                <div style="margin-top:0.5rem;background:var(--bg-primary);border-radius:4px;overflow:hidden;height:20px;">
                                    <div id="creationProgressBar" style="height:100%;background:var(--accent);width:0%;transition:width 0.3s;display:flex;align-items:center;justify-content:center;font-size:0.75rem;color:#000;font-weight:600;"></div>
                                </div>
                            </div>
                            <div id="creationResult" class="hidden"></div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(3)" id="btnStep4Back">Precedent</button>
                                <button class="btn btn-primary" id="btnCreateTorrent">Creer le torrent</button>
                            </div>
                        </div>

                        <!-- Step 5: Preview & Upload -->
                        <div class="workflow-content hidden" id="step-5">
                            <h3 class="workflow-title">Apercu et Upload</h3>
                            <div id="previewLoading">
                                <div class="loading"><div class="spinner"></div><span>Chargement de l'apercu...</span></div>
                            </div>
                            <div id="previewContent">
                                <div class="preview-section">
                                    <h4>Titre</h4>
                                    <input type="text" class="form-control" id="previewTitle" placeholder="Titre du torrent">
                                </div>
                                <div class="preview-section">
                                    <h4>Categorie</h4>
                                    <span class="preview-category" id="previewCategory">-</span>
                                </div>
                                <div class="preview-section">
                                    <h4>Tags</h4>
                                    <div id="previewTags"></div>
                                </div>
                                <div class="preview-section">
                                    <h4>Description BBCode</h4>
                                    <div class="bbcode-tabs">
                                        <div class="bbcode-tab active" onclick="switchBbcodeTab('source', this)">Source BBCode</div>
                                        <div class="bbcode-tab" onclick="switchBbcodeTab('render', this)">Aperçu HTML</div>
                                    </div>
                                    <div id="bbcodeTabSource" class="bbcode-tab-content active">
                                        <textarea class="form-control" id="previewDescription" rows="12" style="border-radius:0 4px 4px 4px;" oninput="updateBbcodePreview()"></textarea>
                                    </div>
                                    <div id="bbcodeTabRender" class="bbcode-tab-content">
                                        <div id="bbcodePreviewRender" class="bbcode-render"></div>
                                    </div>
                                </div>
                                <div class="preview-section">
                                    <h4>Fichiers</h4>
                                    <div class="detail-row"><span class="detail-label">Torrent</span><span class="detail-value" id="createdTorrentPath">-</span></div>
                                    <div class="detail-row"><span class="detail-label">NFO</span><span class="detail-value" id="createdNfoPath">-</span></div>
                                </div>
                            </div>
                            <div id="uploadStatus" style="margin-top: 1rem;"></div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(4)">Precedent</button>
                                <button class="btn btn-success" id="btnFinish" disabled>Uploader sur La-Cale</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div id="page-settings" class="page hidden">
                    <div class="settings-container">
                        <div class="settings-section">
                            <h3>Chemins</h3>
                            <div class="form-group">
                                <label>Chemin racine des medias</label>
                                <input type="text" class="form-control" id="settingRootPath" placeholder="/media">
                            </div>
                            <div class="form-group">
                                <label>Répertoire de sortie (.torrent et .nfo)</label>
                                <input type="text" class="form-control" id="settingOutputDir" placeholder="/torrents">
                                <small style="color:var(--text-muted);">Les fichiers seront créés dans : {répertoire}/{Films|Séries|...}/{nom du torrent}/</small>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Trackers par defaut</h3>
                            <div class="form-group">
                                <label>Liste des trackers (un par ligne)</label>
                                <textarea class="form-control" id="settingTrackers" rows="4"></textarea>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Client Torrent</h3>
                            <div class="form-group">
                                <label>Client pour l'ajout des torrents</label>
                                <select class="form-control" id="settingTorrentClient" onchange="toggleTorrentClientSettings()">
                                    <option value="qbittorrent">qBittorrent</option>
                                    <option value="transmission">Transmission</option>
                                    <option value="deluge">Deluge</option>
                                    <option value="none">Aucun (ne pas ajouter)</option>
                                </select>
                            </div>
                            <!-- qBittorrent Settings -->
                            <div id="qbittorrentSettings" class="client-settings">
                                <h4 style="margin-top:15px;color:var(--text-muted);">qBittorrent</h4>
                                <div class="form-group"><label>URL</label><input type="text" class="form-control" id="settingQbitUrl" placeholder="http://localhost:8080"></div>
                                <div class="form-group"><label>Nom d'utilisateur</label><input type="text" class="form-control" id="settingQbitUsername" placeholder="admin"></div>
                                <div class="form-group"><label>Mot de passe</label><input type="password" class="form-control" id="settingQbitPassword"></div>
                            </div>
                            <!-- Transmission Settings -->
                            <div id="transmissionSettings" class="client-settings" style="display:none;">
                                <h4 style="margin-top:15px;color:var(--text-muted);">Transmission</h4>
                                <div class="form-group"><label>URL</label><input type="text" class="form-control" id="settingTransmissionUrl" placeholder="http://localhost:9091"></div>
                                <div class="form-group"><label>Nom d'utilisateur</label><input type="text" class="form-control" id="settingTransmissionUsername"></div>
                                <div class="form-group"><label>Mot de passe</label><input type="password" class="form-control" id="settingTransmissionPassword"></div>
                            </div>
                            <!-- Deluge Settings -->
                            <div id="delugeSettings" class="client-settings" style="display:none;">
                                <h4 style="margin-top:15px;color:var(--text-muted);">Deluge</h4>
                                <div class="form-group"><label>URL</label><input type="text" class="form-control" id="settingDelugeUrl" placeholder="http://localhost:8112"></div>
                                <div class="form-group"><label>Mot de passe</label><input type="password" class="form-control" id="settingDelugePassword" placeholder="deluge"></div>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>La-Cale</h3>
                            <div class="form-group"><label>Passkey</label><input type="text" class="form-control" id="settingLaCalePasskey"></div>
                            <div class="form-group"><label>Cle API</label><input type="text" class="form-control" id="settingLaCaleApiKey"></div>
                        </div>
                        <div class="settings-section">
                            <h3>Hardlinks</h3>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="settingEnableHardlink">
                                    <label for="settingEnableHardlink">Activer la creation de hardlinks</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Repertoires de destination (un par ligne, un par disque)</label>
                                <textarea class="form-control" id="settingHardlinkDirs" rows="3" placeholder="/mnt/disk1/torrents&#10;/mnt/disk2/torrents"></textarea>
                                <small style="color:var(--text-muted);">Le repertoire sur le meme disque que la source sera automatiquement selectionne</small>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Affichage</h3>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="settingShowProcessed">
                                    <label for="settingShowProcessed">Afficher les fichiers deja traites</label>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-primary btn-full" id="btnSaveSettings">Sauvegarder les parametres</button>
                    </div>
                </div>

                <!-- History Page -->
                <div id="page-history" class="page hidden">
                    <div class="history-container">
                        <div class="history-header">
                            <h3>Fichiers traites</h3>
                            <button class="btn btn-danger" id="btnClearHistory">Effacer l'historique</button>
                        </div>
                        <div class="history-list" id="historyList"><div class="loading"><div class="spinner"></div>Chargement...</div></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <script>
        const TMDB_API_KEY = "49d8d37e45764e7c6794ed7dd2d896d4";
        // Détection automatique du chemin de base (pour accès via /aatm/ ou direct)
        const API_BASE = window.location.pathname.startsWith('/aatm') ? '/aatm' : '';

        const state = {
            currentPage: 'files',
            currentPath: '/media',
            selectedFile: null,
            selectedIsDir: false,
            selectedMediaType: '',
            settings: {},
            workflowStep: 1,
            createdTorrentPath: null,
            createdNfoPath: null,
            mediaType: 'movie',
            releaseInfo: {},
            // Metadata (generic)
            metadataId: '',
            metadataData: null,
            // TMDB (films/series)
            tmdbId: '',
            tmdbData: null,
            // Google Books (ebooks)
            bookId: '',
            bookData: null,
            // Steam (games)
            steamId: '',
            gameData: null,
            nfoContent: '',
            previewData: null
        };

        // ============ PARSER ============
        function parseMediaInfo(nfo) {
            const info = {};
            if (nfo.match(/Format\s*:\s*Matroska/i)) info.container = 'MKV';
            else if (nfo.match(/Format\s*:\s*MPEG-4/i)) info.container = 'MP4';

            // Séparer les sections par double saut de ligne pour extraire résolution/codec de la section Video uniquement
            const allSections = nfo.split(/(?:\r?\n){2,}/);
            const videoSection = allSections.find(s => /^Video\s*(?:#\d+)?/im.test(s));

            // Résolution : extraire depuis la section Video uniquement (évite les images de couverture embarquées)
            const videoBlock = videoSection || nfo;
            const widthMatch = videoBlock.match(/Width\s*:\s*([\d\s]+)/);
            const heightMatch = videoBlock.match(/Height\s*:\s*([\d\s]+)/);
            if (widthMatch || heightMatch) {
                const w = widthMatch ? parseInt(widthMatch[1].replace(/\s/g, ''), 10) : 0;
                const h = heightMatch ? parseInt(heightMatch[1].replace(/\s/g, ''), 10) : 0;
                // 4K si largeur >= 3840 OU hauteur >= 2100
                if (w >= 3840 || h >= 2100) info.resolution = '2160p';
                else if (w >= 1920 || h >= 1000) info.resolution = '1080p';
                else if (w >= 1280 || h >= 700) info.resolution = '720p';
                else info.resolution = '480p';
            }

            // Codec vidéo : extraire depuis la section Video uniquement
            if (videoBlock.match(/Writing library\s*:\s*x265/i)) info.codec = 'x265';
            else if (videoBlock.match(/Format\s*:\s*HEVC/i)) info.codec = 'HEVC';
            else if (videoBlock.match(/Writing library\s*:\s*x264/i)) info.codec = 'x264';
            else if (videoBlock.match(/Format\s*:\s*AVC/i)) info.codec = 'AVC';

            if (nfo.match(/Format\s*:\s*E-AC-3/i)) info.audio = 'EAC3';
            else if (nfo.match(/Format\s*:\s*AC-3/i)) info.audio = 'AC3';
            else if (nfo.match(/Format\s*:\s*DTS-HD/i)) info.audio = 'DTS-HD';
            else if (nfo.match(/Format\s*:\s*DTS/i)) info.audio = 'DTS';
            else if (nfo.match(/Format\s*:\s*TrueHD/i)) info.audio = 'TrueHD';
            else if (nfo.match(/Format\s*:\s*AAC/i)) info.audio = 'AAC';

            const channelMatches = [...nfo.matchAll(/Channel\(s\)\s*:\s*(\d+)/g)];
            if (channelMatches.length > 0) {
                const maxCh = Math.max(...channelMatches.map(m => parseInt(m[1], 10)));
                if (maxCh >= 8) info.audioChannels = '7.1';
                else if (maxCh >= 6) info.audioChannels = '5.1';
                else if (maxCh >= 2) info.audioChannels = '2.0';
            }

            const audioTracks = [];
            const subtitleTracks = [];
            const sections = nfo.split(/(?:\r?\n){2,}/);
            let frenchAudio = false, nonFrenchAudio = false;

            // Fonction pour nettoyer et normaliser les langues
            const normalizeLang = (lang) => {
                lang = lang.trim();
                const match = lang.match(/^([\w\-]+)/i);
                if (match) {
                    const base = match[1].toLowerCase();
                    if (base === 'french' || base === 'français') return 'Français';
                    if (base === 'english') return 'Anglais';
                    if (base === 'spanish' || base === 'español') return 'Espagnol';
                    if (base === 'german' || base === 'deutsch') return 'Allemand';
                    if (base === 'italian' || base === 'italiano') return 'Italien';
                    if (base === 'portuguese') return 'Portugais';
                    if (base === 'japanese') return 'Japonais';
                    if (base === 'korean') return 'Coréen';
                    if (base === 'chinese') return 'Chinois';
                    if (base === 'russian') return 'Russe';
                    if (base === 'arabic') return 'Arabe';
                }
                return lang;
            };

            // Fonction pour obtenir le codec audio avec nom commercial
            const getAudioCodec = (section) => {
                let codec = '';
                let commercial = '';

                const formatMatch = section.match(/Format\s*:\s*([^\r\n]+)/i);
                if (formatMatch) {
                    const fmt = formatMatch[1].trim();
                    if (fmt.match(/E-AC-3/i)) codec = 'EAC3';
                    else if (fmt.match(/AC-3/i)) codec = 'AC3';
                    else if (fmt.match(/DTS-HD MA/i)) codec = 'DTS-HD MA';
                    else if (fmt.match(/DTS-HD/i)) codec = 'DTS-HD';
                    else if (fmt.match(/DTS/i)) codec = 'DTS';
                    else if (fmt.match(/TrueHD|MLP\s*FBA/i)) codec = 'TrueHD';
                    else if (fmt.match(/AAC/i)) codec = 'AAC';
                    else if (fmt.match(/FLAC/i)) codec = 'FLAC';
                    else if (fmt.match(/Opus/i)) codec = 'Opus';
                    else if (fmt.match(/MP3|MPEG Audio/i)) codec = 'MP3';
                    else if (fmt.match(/PCM/i)) codec = 'PCM';
                    else codec = fmt;
                }

                const commercialMatch = section.match(/Commercial name\s*:\s*([^\r\n]+)/i);
                if (commercialMatch) {
                    commercial = commercialMatch[1].trim();
                }

                return commercial ? `${codec} (${commercial})` : codec;
            };

            // Fonction pour obtenir les canaux audio
            const getAudioChannels = (section) => {
                const channelMatch = section.match(/Channel\(s\)\s*:\s*(\d+)/i);
                if (channelMatch) {
                    const ch = parseInt(channelMatch[1], 10);
                    if (ch >= 8) return '7.1';
                    if (ch >= 6) return '5.1';
                    if (ch >= 2) return '2.0';
                    return '1.0';
                }
                return '';
            };

            // Fonction pour obtenir le bitrate
            const getBitrate = (section) => {
                const bitrateMatch = section.match(/Bit rate\s*:\s*([^\r\n]+)/i);
                if (bitrateMatch) {
                    return bitrateMatch[1].trim();
                }
                return '';
            };

            for (const s of sections) {
                // Extraire le bitrate vidéo de la section Video
                const videoHeader = s.match(/^Video\s*(?:#\d+)?/im);
                if (videoHeader && !info.videoBitrate) {
                    const bitrate = getBitrate(s);
                    if (bitrate) info.videoBitrate = bitrate;
                }
                const audioHeader = s.match(/^Audio\s*(?:#\d+)?/im);
                const textHeader = s.match(/^(?:Text|Subtitle)\s*(?:#\d+)?/im);
                const hasAudioProps = s.includes('Channel(s)') && s.includes('Sampling rate');

                if (audioHeader || (!textHeader && hasAudioProps)) {
                    const langMatch = s.match(/Language\s*:\s*([^\r\n]+)/i);
                    if (langMatch) {
                        const lang = normalizeLang(langMatch[1]);
                        const codec = getAudioCodec(s);
                        const channels = getAudioChannels(s);
                        const bitrate = getBitrate(s);

                        audioTracks.push({
                            language: lang,
                            codec: codec,
                            channels: channels,
                            bitrate: bitrate
                        });

                        const lowerLang = lang.toLowerCase();
                        if (lowerLang.includes('français') || lowerLang.includes('french')) frenchAudio = true;
                        else nonFrenchAudio = true;
                    }
                } else if (textHeader) {
                    const langMatch = s.match(/Language\s*:\s*([^\r\n]+)/i);
                    const titleMatch = s.match(/Title\s*:\s*([^\r\n]+)/i);
                    const formatMatch = s.match(/Format\s*:\s*([^\r\n]+)/i);
                    if (langMatch) {
                        const lang = normalizeLang(langMatch[1]);
                        const title = titleMatch ? titleMatch[1].trim() : '';
                        const fmt = formatMatch ? formatMatch[1].trim().toUpperCase() : '';

                        // Déterminer le type de sous-titre
                        let subType = '';
                        if (title.toLowerCase().includes('forced')) subType = 'Forcés';
                        else if (title.toLowerCase().includes('sdh')) subType = 'SDH';
                        else if (title.toLowerCase().includes('full')) subType = 'Complet';

                        // Déterminer le format (SRT ou PGS)
                        let subFormat = '';
                        if (fmt.includes('UTF-8') || fmt.includes('SRT') || fmt.includes('ASS') || fmt.includes('SSA')) {
                            subFormat = 'SRT';
                        } else if (fmt.includes('PGS') || fmt.includes('HDMV')) {
                            subFormat = 'PGS';
                        }

                        // Construire le suffixe
                        let suffix = '';
                        if (subType && subFormat) suffix = ` (${subType} ${subFormat})`;
                        else if (subType) suffix = ` (${subType})`;
                        else if (subFormat) suffix = ` (${subFormat})`;

                        subtitleTracks.push(lang + suffix);
                    }
                }
            }

            if (audioTracks.length > 0) {
                info.audioTracks = audioTracks;
                info.audioLanguages = audioTracks.map(t => t.language);
                // Extraire les codecs audio uniques pour les tags
                const uniqueCodecs = new Set();
                audioTracks.forEach(t => {
                    if (t.codec) {
                        // Extraire le codec de base (avant la parenthèse)
                        const baseCodec = t.codec.split(' (')[0].trim();
                        // Vérifier si c'est Atmos
                        const isAtmos = t.codec.toLowerCase().includes('atmos');
                        if (isAtmos) {
                            if (baseCodec.includes('TrueHD')) uniqueCodecs.add('TrueHD Atmos');
                            else if (baseCodec.includes('EAC3') || baseCodec.includes('E-AC-3')) uniqueCodecs.add('E-AC3 Atmos');
                            else uniqueCodecs.add(baseCodec + ' Atmos');
                        } else {
                            uniqueCodecs.add(baseCodec);
                        }
                    }
                });
                info.audioCodecs = Array.from(uniqueCodecs);
            }
            if (subtitleTracks.length > 0) info.subtitleLanguages = subtitleTracks;
            if (frenchAudio && nonFrenchAudio) info.language = 'MULTi';
            else if (frenchAudio) info.language = 'FRENCH';

            const hdr = [];
            if (nfo.includes('HDR10+')) hdr.push('HDR10+');
            else if (nfo.includes('HDR10') || nfo.match(/SMPTE ST 2086/)) hdr.push('HDR10');
            if (nfo.includes('Dolby Vision')) hdr.push('DV');
            if (hdr.length > 0) info.hdr = hdr;

            return info;
        }

        function parseReleaseName(name, nfoContent = '') {
            const info = {};
            let cleanName = name.trim();

            // Retirer l'extension vidéo pour le parsing
            cleanName = cleanName.replace(/\.(mkv|mp4|avi|iso)$/i, '');

            // Extraire le groupe de release (après le dernier tiret)
            const groupMatch = cleanName.match(/-([a-zA-Z0-9\[\]]+)$/);
            if (groupMatch) {
                const potentialGroup = groupMatch[1];
                // Ne pas considérer comme groupe si c'est une résolution
                if (!/^(2160|1080|720|576|480|4320)p$/i.test(potentialGroup)) {
                    info.releaseGroup = potentialGroup;
                }
            }

            const patterns = {
                year: /\b(19|20)\d{2}\b/g,
                season: /\b(?:S|Season)\s?(\d{1,2})\b|\b(Complete|Integrale)\b/gi,
                episode: /\b(?:E|Episode)\s?(\d{1,3})\b/gi,
                seasonEpisode: /\bS(\d{1,2})E(\d{1,3})\b/gi,
                source: /\b(Bluray|BluRay|BDRip|BRRip|WEBRip|WebRip|WEB-DL|WEBDL|WEB|HDTV|DVDRip)\b/gi,
                ebookFormat: /\.(epub|pdf|mobi|azw3?|cbr|cbz)$/i
            };

            let firstTagIndex = cleanName.length;

            // Détecter le format ebook depuis l'extension
            const ebookMatch = patterns.ebookFormat.exec(cleanName);
            if (ebookMatch) {
                info.container = ebookMatch[1].toUpperCase();
                // Retirer l'extension pour le parsing du titre
                cleanName = cleanName.replace(patterns.ebookFormat, '');
            }

            const yearMatch = patterns.year.exec(cleanName);
            if (yearMatch) { info.year = yearMatch[0]; if (yearMatch.index < firstTagIndex) firstTagIndex = yearMatch.index; }

            patterns.seasonEpisode.lastIndex = 0;
            const sxeMatch = patterns.seasonEpisode.exec(cleanName);
            if (sxeMatch) {
                info.season = "S" + sxeMatch[1].padStart(2, '0');
                info.episode = "E" + sxeMatch[2].padStart(2, '0');
                if (sxeMatch.index < firstTagIndex) firstTagIndex = sxeMatch.index;
            } else {
                patterns.season.lastIndex = 0;
                const seasonMatch = patterns.season.exec(cleanName);
                if (seasonMatch) {
                    info.season = seasonMatch[2] ? seasonMatch[2].toUpperCase() : "S" + seasonMatch[1].padStart(2, '0');
                    if (seasonMatch.index < firstTagIndex) firstTagIndex = seasonMatch.index;
                }
                patterns.episode.lastIndex = 0;
                const epMatch = patterns.episode.exec(cleanName);
                if (epMatch) { info.episode = "E" + epMatch[1].padStart(2, '0'); if (epMatch.index < firstTagIndex) firstTagIndex = epMatch.index; }
            }

            patterns.source.lastIndex = 0;
            const sourceMatch = patterns.source.exec(cleanName);
            if (sourceMatch) { info.source = sourceMatch[0]; if (sourceMatch.index < firstTagIndex) firstTagIndex = sourceMatch.index; }

            let potentialTitle = cleanName.substring(0, firstTagIndex).replace(/\./g, ' ').replace(/_/g, ' ').replace(/[-()]+$/, '').trim();
            if (potentialTitle) info.title = potentialTitle;

            if (nfoContent) {
                const nfoInfo = parseMediaInfo(nfoContent);
                Object.assign(info, nfoInfo);
            }

            return info;
        }

        // ============ GÉNÉRATION DE NOM SELON LES RÈGLES LA CALE ============

        function normalizeTitle(title) {
            if (!title) return '';
            // Supprimer les accents
            let normalized = title.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            // Remplacer les cédilles
            normalized = normalized.replace(/[çÇ]/g, m => m === 'ç' ? 'c' : 'C');
            // Remplacer les apostrophes par un point
            normalized = normalized.replace(/[''`]/g, '.');
            // Supprimer les caractères spéciaux interdits
            normalized = normalized.replace(/[,;}{[\]:]/g, '');
            // Remplacer les tirets par des points
            normalized = normalized.replace(/-/g, '.');
            // Première lettre de chaque mot en majuscule
            normalized = normalized.split(/\s+/).map(word => {
                if (word.length === 0) return '';
                if (word === word.toUpperCase() && word.length <= 4) return word;
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            }).join('.');
            // Nettoyer les points multiples
            normalized = normalized.replace(/\.{2,}/g, '.').replace(/^\.|\.$/g, '');
            return normalized;
        }

        function generateMovieReleaseName(info) {
            const parts = [];

            // 1. Titre (normalisé)
            if (info.title) parts.push(normalizeTitle(info.title));

            // 2. Année
            if (info.year) parts.push(info.year);

            // 3. Info (REPACK, PROPER, etc.)
            if (info.info) parts.push(info.info.toUpperCase());

            // 4. Edition
            if (info.edition) parts.push(info.edition);

            // 5. IMAX
            if (info.imax) parts.push('iMAX');

            // 6. Langue
            if (info.language) {
                const lang = info.language.toUpperCase();
                parts.push(lang === 'MULTI' ? 'MULTi' : lang);
            }

            // 7. LangueInfo (VFF, VFQ, etc.)
            if (info.languageInfo) parts.push(info.languageInfo.toUpperCase());

            // 8. HDR/DV
            if (info.hdr && info.hdr.length > 0) {
                const hdrOrder = ['HDR10+', 'HDR10', 'HDR', 'DV', 'HLG', 'SDR'];
                const sortedHdr = info.hdr
                    .map(h => h.toUpperCase().replace('DOLBY VISION', 'DV'))
                    .sort((a, b) => hdrOrder.indexOf(a) - hdrOrder.indexOf(b));
                parts.push(...sortedHdr);
            }

            // 9. Résolution
            if (info.resolution) {
                const res = info.resolution.toLowerCase();
                parts.push(res.endsWith('p') ? res : res + 'p');
            }

            // 10. Plateforme
            if (info.platform) parts.push(info.platform.toUpperCase());

            // 11. Source (normalisée)
            if (info.source) {
                let source = info.source;
                const s = source.toLowerCase();
                if (s === 'web-dl' || s === 'webdl') source = 'WEB-DL';
                else if (s === 'webrip') source = 'WEBRip';
                else if (s === 'bluray' || s === 'blu-ray' || s === 'bdrip' || s === 'brrip') source = 'BluRay';
                else if (s === 'remux') source = 'REMUX';
                else if (s === 'hdlight') source = 'HDLight';
                else if (s === '4klight') source = '4KLight';
                else if (s === 'dvdrip') source = 'DVDRip';
                else if (s === 'hdtv') source = 'HDTV';
                parts.push(source);
            }

            // 12. Audio (normalisé)
            if (info.audio) {
                let audio = info.audio.toUpperCase();
                if (audio === 'DDP' || audio === 'E-AC-3') audio = 'EAC3';
                if (audio === 'DD' || audio === 'AC-3') audio = 'AC3';
                parts.push(audio);
            }

            // 13. Canaux audio
            if (info.audioChannels) parts.push(info.audioChannels);

            // 14. AudioSpec (Atmos)
            if (info.audioSpec) parts.push(info.audioSpec);

            // 15. Codec vidéo (normalisé)
            if (info.codec) {
                let codec = info.codec.toUpperCase();
                if (codec === 'H264' || codec === 'H.264' || codec === 'AVC') codec = 'x264';
                if (codec === 'H265' || codec === 'H.265' || codec === 'HEVC') codec = 'x265';
                parts.push(codec);
            }

            // Construire le nom
            const baseName = parts.join('.');
            const team = info.releaseGroup || 'NoTag';
            return `${baseName}-${team}`;
        }

        function generateSeriesReleaseName(info, mediaType) {
            const parts = [];

            // 1. Titre
            if (info.title) parts.push(normalizeTitle(info.title));

            // 2. Année (facultatif pour séries)
            if (info.year) parts.push(info.year);

            // 3. SaisonEpisode
            if (mediaType === 'season') {
                if (info.season) {
                    if (info.season.toUpperCase() === 'COMPLETE' || info.season.toUpperCase() === 'INTEGRALE') {
                        parts.push('COMPLETE');
                    } else {
                        parts.push(info.season.toUpperCase());
                    }
                }
            } else {
                if (info.season && info.episode) {
                    parts.push(`${info.season.toUpperCase()}${info.episode.toUpperCase()}`);
                } else if (info.episode) {
                    parts.push(info.episode.toUpperCase());
                } else if (info.season) {
                    parts.push(info.season.toUpperCase());
                }
            }

            // 4-15. Mêmes tags que les films
            if (info.info) parts.push(info.info.toUpperCase());
            if (info.edition) parts.push(info.edition);
            if (info.imax) parts.push('iMAX');
            if (info.language) parts.push(info.language === 'MULTI' ? 'MULTi' : info.language.toUpperCase());
            if (info.languageInfo) parts.push(info.languageInfo.toUpperCase());
            if (info.hdr && info.hdr.length > 0) parts.push(...info.hdr.map(h => h.toUpperCase()));
            if (info.resolution) parts.push(info.resolution.toLowerCase().endsWith('p') ? info.resolution.toLowerCase() : info.resolution.toLowerCase() + 'p');
            if (info.platform) parts.push(info.platform.toUpperCase());
            if (info.source) {
                let source = info.source.toLowerCase();
                if (source === 'bluray' || source === 'bdrip') source = 'BluRay';
                else if (source === 'web-dl' || source === 'webdl') source = 'WEB-DL';
                else if (source === 'webrip') source = 'WEBRip';
                else source = info.source;
                parts.push(source);
            }
            if (info.audio) parts.push(info.audio.toUpperCase());
            if (info.audioChannels) parts.push(info.audioChannels);
            if (info.audioSpec) parts.push(info.audioSpec);
            if (info.codec) {
                let codec = info.codec.toUpperCase();
                if (codec === 'HEVC' || codec === 'H265') codec = 'x265';
                if (codec === 'AVC' || codec === 'H264') codec = 'x264';
                parts.push(codec);
            }

            const baseName = parts.join('.');
            const team = info.releaseGroup || 'NoTag';
            return `${baseName}-${team}`;
        }

        function generateReleaseName(info, mediaType) {
            if (mediaType === 'movie') {
                return generateMovieReleaseName(info);
            } else if (mediaType === 'season' || mediaType === 'episode') {
                return generateSeriesReleaseName(info, mediaType);
            }
            // Pour ebook/game, garder le nom original
            return info.title || '';
        }

        // ============ PRESENTATION ============
        async function generatePresentation(data) {
            const { tmdbId, mediaType, releaseInfo, nfoContent, totalSize } = data;

            // Pour les ebooks, utiliser Google Books
            if (mediaType === 'ebook') {
                return generateEbookPresentation(data);
            }

            // Pour les jeux, utiliser Steam
            if (mediaType === 'game') {
                return generateGamePresentation(data);
            }

            const type = (mediaType === 'movie') ? 'movie' : 'tv';
            let tmdbData = {};

            try {
                const res = await fetch(`https://api.themoviedb.org/3/${type}/${tmdbId}?api_key=${TMDB_API_KEY}&language=fr-FR`);
                tmdbData = await res.json();
            } catch (e) { console.error("TMDB fetch error:", e); }

            const title = tmdbData.title || tmdbData.name || releaseInfo.title || "Unknown Title";
            const year = (tmdbData.release_date || tmdbData.first_air_date || "").substring(0, 4) || releaseInfo.year || "";
            const posterUrl = tmdbData.poster_path ? `https://image.tmdb.org/t/p/w500${tmdbData.poster_path}` : "";
            const genres = (tmdbData.genres || []).map(g => g.name).join(", ") || "Non spécifié";
            const score = tmdbData.vote_average ? `${tmdbData.vote_average.toFixed(3)}/10` : "N/A";
            const overview = tmdbData.overview || "Aucune description disponible.";

            let size = totalSize || "Variable";
            if (!totalSize) {
                const sizeMatch = nfoContent.match(/File\s*size\s*:\s*([0-9.]+\s*[KMGT]?i?B)/i);
                if (sizeMatch) size = sizeMatch[1];
            }

            // Générer la liste des pistes audio avec codec, nom commercial, canaux et bitrate
            let audioSection = "";
            if (releaseInfo.audioTracks && releaseInfo.audioTracks.length > 0) {
                const audioLines = releaseInfo.audioTracks.map(track => {
                    let line = track.language;
                    if (track.codec) line += ` : ${track.codec}`;
                    if (track.channels) line += ` ${track.channels}`;
                    if (track.bitrate) line += ` @ ${track.bitrate}`;
                    return line;
                });
                audioSection = audioLines.join("\n");
            } else if (releaseInfo.audioLanguages && releaseInfo.audioLanguages.length > 0) {
                const audio = releaseInfo.audio || "";
                const channels = releaseInfo.audioChannels || "";
                audioSection = releaseInfo.audioLanguages.map(lang => {
                    let line = lang;
                    if (audio) line += ` : ${audio}`;
                    if (channels) line += ` ${channels}`;
                    return line;
                }).join("\n");
            } else {
                audioSection = releaseInfo.language || "Non spécifié";
            }

            // Récupérer tous les sous-titres
            let subsSection = "Aucun";
            if (releaseInfo.subtitleLanguages && releaseInfo.subtitleLanguages.length > 0) {
                subsSection = releaseInfo.subtitleLanguages.join("\n");
            }

            const resolution = releaseInfo.resolution || "Non spécifié";
            const container = releaseInfo.container || "MKV";
            const video = releaseInfo.codec || "Non spécifié";
            const videoBitrate = releaseInfo.videoBitrate || "";
            const hdr = (releaseInfo.hdr && releaseInfo.hdr.length > 0) ? releaseInfo.hdr.join(" / ") : "";

            return `[center]
[img]${posterUrl}[/img]

[size=6][color=#eab308][b]${title} (${year})[/b][/color][/size]

[b]Note :[/b] ${score}
[b]Genre :[/b] ${genres}

[quote]${overview}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Qualité :[/b] ${resolution}${hdr ? ` ${hdr}` : ''}
[b]Format :[/b] ${container}
[b]Codec Vidéo :[/b] ${video}${videoBitrate ? ` @ ${videoBitrate}` : ''}
[b]Audio :[/b]
${audioSection}
[b]Sous-titres :[/b]
${subsSection}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        function generateEbookPresentation(data) {
            const { releaseInfo, totalSize } = data;
            const bookData = state.bookData || {};

            const title = bookData.title || releaseInfo.title || "Titre inconnu";
            const authors = (bookData.authors || []).join(", ") || "Auteur inconnu";
            const year = (bookData.publishedDate || "").substring(0, 4) || releaseInfo.year || "";
            const description = bookData.description || "Aucune description disponible.";
            const categories = (bookData.categories || []).join(", ") || "Non spécifié";
            const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || "";
            const pageCount = bookData.pageCount || "Non spécifié";
            const publisher = bookData.publisher || "Non spécifié";

            // Détecter le format depuis le nom du fichier ou releaseInfo
            let format = "EPUB";
            if (releaseInfo.container) {
                format = releaseInfo.container.toUpperCase();
            }

            let size = totalSize || "Variable";

            // Langue
            let language = bookData.language || "Non spécifié";
            if (language === "fr") language = "Français";
            else if (language === "en") language = "Anglais";

            return `[center]
${thumbnail ? `[img]${thumbnail}[/img]` : ''}

[size=6][color=#eab308][b]${title}${year ? ' (' + year + ')' : ''}[/b][/color][/size]

[b]Auteur :[/b] ${authors}
[b]Genre :[/b] ${categories}

[quote]${description.replace(/<[^>]*>/g, '')}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Editeur :[/b] ${publisher}
[b]Pages :[/b] ${pageCount}
[b]Format :[/b] ${format}
[b]Langue :[/b] ${language}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        function generateGamePresentation(data) {
            const { releaseInfo, totalSize } = data;
            const gameData = state.gameData || {};

            const title = gameData.name || releaseInfo.title || "Titre inconnu";
            const description = gameData.short_description || gameData.detailed_description || "Aucune description disponible.";
            const genres = (gameData.genres || []).map(g => g.description).join(", ") || "Non spécifié";
            const releaseDate = gameData.release_date?.date || releaseInfo.year || "Non spécifié";
            const developers = (gameData.developers || []).join(", ") || "Non spécifié";
            const publishers = (gameData.publishers || []).join(", ") || "Non spécifié";
            const headerImage = gameData.header_image || "";
            const metacritic = gameData.metacritic?.score ? `${gameData.metacritic.score}/100` : "N/A";

            let size = totalSize || "Variable";

            // Langues supportées
            let languages = "Non spécifié";
            if (gameData.supported_languages) {
                // Nettoyer le HTML des langues
                languages = gameData.supported_languages.replace(/<[^>]*>/g, '').substring(0, 100);
                if (gameData.supported_languages.length > 100) languages += '...';
            }

            return `[center]
${headerImage ? `[img]${headerImage}[/img]` : ''}

[size=6][color=#eab308][b]${title}[/b][/color][/size]

[b]Date de sortie :[/b] ${releaseDate}
[b]Genre :[/b] ${genres}
[b]Note Metacritic :[/b] ${metacritic}

[quote]${description.replace(/<[^>]*>/g, '')}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Developpeur :[/b] ${developers}
[b]Editeur :[/b] ${publishers}
[b]Langues :[/b] ${languages}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        // ============ UI FUNCTIONS ============
        document.addEventListener('DOMContentLoaded', () => {
            initNavigation();
            loadSettings();
            checkApiStatus();
            setInterval(checkApiStatus, 30000);

            document.getElementById('btnStep1Next').addEventListener('click', () => goToStep(2));
            document.getElementById('btnStep2Next').addEventListener('click', () => goToStep(3));
            document.getElementById('btnMetadataSearch').addEventListener('click', searchMetadata);
            document.getElementById('metadataQuery').addEventListener('keydown', e => { if (e.key === 'Enter') searchMetadata(); });
            document.getElementById('btnCreateTorrent').addEventListener('click', createTorrent);
            document.getElementById('btnFinish').addEventListener('click', finishWorkflow);
            document.getElementById('btnSaveSettings').addEventListener('click', saveSettings);
            document.getElementById('btnClearHistory').addEventListener('click', clearHistory);
            document.getElementById('btnCreateFromFolder').addEventListener('click', createTorrentFromCurrentFolder);

            document.querySelectorAll('.media-type-btn').forEach(btn => {
                btn.addEventListener('click', () => selectMediaType(btn.dataset.type));
            });
        });

        function initNavigation() {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', () => {
                    // Si on clique sur "Créer Torrent" dans le menu, recharger la page
                    if (item.dataset.page === 'create') {
                        location.reload();
                        return;
                    }
                    navigateTo(item.dataset.page);
                });
            });
        }

        function navigateTo(page) {
            state.currentPage = page;
            document.querySelectorAll('.nav-item').forEach(item => item.classList.toggle('active', item.dataset.page === page));
            document.querySelectorAll('.page').forEach(p => p.classList.add('hidden'));
            document.getElementById(`page-${page}`).classList.remove('hidden');

            const titles = { files: 'Explorateur de fichiers', create: 'Creer un torrent', settings: 'Parametres', history: 'Historique' };
            document.getElementById('pageTitle').textContent = titles[page];

            if (page === 'files') loadFiles(state.currentPath);
            else if (page === 'settings') loadSettingsForm();
            else if (page === 'history') loadHistory();
            else if (page === 'create') updateWorkflowUI();
        }

        async function checkApiStatus() {
            try {
                const res = await fetch(`${API_BASE}/health`);
                document.getElementById('statusIndicator').className = res.ok ? 'status-indicator online' : 'status-indicator offline';
                document.getElementById('statusText').textContent = res.ok ? 'API en ligne' : 'API hors ligne';
            } catch (e) {
                document.getElementById('statusIndicator').className = 'status-indicator offline';
                document.getElementById('statusText').textContent = 'API hors ligne';
            }
        }

        async function loadFiles(path) {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';
            try {
                const res = await fetch(`${API_BASE}/api/files?path=${encodeURIComponent(path)}`);
                const files = await res.json();
                state.currentPath = path;
                updateBreadcrumb(path);
                renderFiles(files);
            } catch (e) {
                fileList.innerHTML = `<div class="empty-state"><p>Erreur: ${e.message}</p></div>`;
            }
        }

        function updateBreadcrumb(path) {
            const breadcrumb = document.getElementById('breadcrumb');
            const parts = path.split('/').filter(p => p);
            let html = '<span class="breadcrumb-item" onclick="loadFiles(\'/\')">~</span>';
            let currentPath = '';
            parts.forEach((part, i) => {
                currentPath += '/' + part;
                html += `<span class="breadcrumb-separator">/</span>`;
                html += i === parts.length - 1
                    ? `<span class="breadcrumb-item current">${part}</span>`
                    : `<span class="breadcrumb-item" onclick="loadFiles('${currentPath}')">${part}</span>`;
            });
            breadcrumb.innerHTML = html;
        }

        function renderFiles(files) {
            const fileList = document.getElementById('fileList');
            if (!files || files.length === 0) { fileList.innerHTML = '<div class="empty-state"><p>Aucun fichier media trouve</p></div>'; return; }

            let filteredFiles = state.settings.showProcessed ? files : files.filter(f => !f.isProcessed);
            filteredFiles.sort((a, b) => { if (a.isDir && !b.isDir) return -1; if (!a.isDir && b.isDir) return 1; return a.name.localeCompare(b.name); });

            const getFileIcon = (file) => {
                if (file.isDir) return '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>';
                if (file.mediaType === 'ebook') return '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>';
                if (file.mediaType === 'game') return '<rect x="2" y="6" width="20" height="12" rx="2"/><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><circle cx="17" cy="10" r="1"/><circle cx="15" cy="13" r="1"/>';
                return '<polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>';
            };

            const getFileClass = (file) => {
                if (file.isDir) return 'folder';
                if (file.mediaType === 'ebook') return 'ebook';
                if (file.mediaType === 'game') return 'game';
                return 'video';
            };

            fileList.innerHTML = filteredFiles.map(file => `
                <div class="file-item ${file.isProcessed ? 'processed' : ''}" data-name="${file.name}" data-isdir="${file.isDir}" data-mediatype="${file.mediaType || ''}" onclick="selectFile('${file.name.replace(/'/g, "\\'")}', ${file.isDir}, '${file.mediaType || ''}')">
                    <svg class="file-icon ${getFileClass(file)}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        ${getFileIcon(file)}
                    </svg>
                    <span class="file-name">${file.name}</span>
                    ${file.isProcessed ? '<span class="processed-badge">Traite</span>' : ''}
                    <span class="file-size">${file.isDir ? 'Dossier' : formatSize(file.size)}</span>
                </div>
            `).join('');
        }

        async function selectFile(name, isDir, mediaType = '') {
            const fullPath = state.currentPath + '/' + name;
            document.querySelectorAll('.file-item').forEach(el => el.classList.toggle('selected', el.dataset.name === name));

            // Pour les dossiers, naviguer dedans
            if (isDir) { loadFiles(fullPath); state.selectedFile = null; return; }

            state.selectedFile = fullPath;
            state.selectedIsDir = isDir;
            state.selectedMediaType = mediaType;
            document.getElementById('detailsTitle').textContent = name;
            document.getElementById('fileActions').style.display = 'flex';

            const detailsContent = document.getElementById('detailsContent');
            detailsContent.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';

            try {
                // Pour les ebooks et jeux, pas de MediaInfo
                if (mediaType === 'ebook' || mediaType === 'game') {
                    const sizeRes = await fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(fullPath)}`);
                    const sizeData = await sizeRes.json();
                    const typeLabel = mediaType === 'ebook' ? 'E-book' : 'Jeu video';
                    detailsContent.innerHTML = `
                        <div class="detail-section">
                            <h4>Informations</h4>
                            <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${fullPath}</span></div>
                            <div class="detail-row"><span class="detail-label">Taille</span><span class="detail-value">${sizeData.size}</span></div>
                            <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value">${typeLabel}</span></div>
                        </div>
                    `;
                } else {
                    const [sizeRes, mediaRes] = await Promise.all([
                        fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(fullPath)}`),
                        fetch(`${API_BASE}/api/mediainfo?path=${encodeURIComponent(fullPath)}`)
                    ]);
                    const sizeData = await sizeRes.json();
                    const mediaData = await mediaRes.json();

                    detailsContent.innerHTML = `
                        <div class="detail-section">
                            <h4>Informations</h4>
                            <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${fullPath}</span></div>
                            <div class="detail-row"><span class="detail-label">Taille</span><span class="detail-value">${sizeData.size}</span></div>
                        </div>
                        <div class="detail-section">
                            <h4>MediaInfo</h4>
                            <div class="mediainfo-output">${escapeHtml(mediaData.mediainfo)}</div>
                        </div>
                    `;
                }
            } catch (e) {
                detailsContent.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }

            document.getElementById('btnStartWorkflow').onclick = () => startWorkflow(fullPath, name, mediaType);
        }

        function startWorkflow(path, name, mediaType = '') {
            state.selectedFile = path;
            state.workflowStep = 1;
            state.releaseInfo = parseReleaseName(name);
            state.metadataId = '';
            state.metadataData = null;
            state.tmdbId = '';
            state.tmdbData = null;
            state.bookId = '';
            state.bookData = null;
            state.steamId = '';
            state.gameData = null;

            // Auto-sélectionner le type de média si détecté
            if (mediaType === 'ebook') {
                selectMediaType('ebook');
            } else if (mediaType === 'game') {
                selectMediaType('game');
            } else {
                selectMediaType('movie'); // Par défaut
            }

            document.getElementById('selectedSource').innerHTML = `
                <div class="alert alert-success"><strong>Source:</strong> ${name}</div>
                <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${path}</span></div>
            `;

            // Générer le nom du torrent selon les règles La Cale
            const generatedName = generateReleaseName(state.releaseInfo, state.mediaType);
            document.getElementById('torrentName').value = generatedName || name.replace(/\.[^/.]+$/, '');
            document.getElementById('metadataQuery').value = state.releaseInfo.title || '';

            updateReleaseTags();
            document.getElementById('btnStep1Next').disabled = false;
            navigateTo('create');
        }

        function createTorrentFromCurrentFolder() {
            const path = state.currentPath;
            const name = path.split('/').pop() || 'dossier';

            // Lancer le workflow avec le dossier courant
            startWorkflow(path, name, '');
        }

        function selectMediaType(type) {
            state.mediaType = type;
            document.querySelectorAll('.media-type-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.type === type));
        }

        function updateReleaseTags() {
            const info = state.releaseInfo;
            const tags = [];
            if (info.year) tags.push(`<span class="tag year">${info.year}</span>`);
            if (info.resolution) tags.push(`<span class="tag resolution">${info.resolution}</span>`);
            if (info.source) tags.push(`<span class="tag source">${info.source}</span>`);
            if (info.codec) tags.push(`<span class="tag codec">${info.codec}</span>`);
            if (info.audio) tags.push(`<span class="tag audio">${info.audio}</span>`);
            if (info.audioChannels) tags.push(`<span class="tag audio">${info.audioChannels}</span>`);
            if (info.language) tags.push(`<span class="tag language">${info.language}</span>`);
            if (info.hdr) info.hdr.forEach(h => tags.push(`<span class="tag hdr">${h}</span>`));
            if (info.releaseGroup) tags.push(`<span class="tag group">-${info.releaseGroup}</span>`);
            if (info.audioLanguages) info.audioLanguages.forEach(l => tags.push(`<span class="tag language">${l}</span>`));
            document.getElementById('releaseTags').innerHTML = tags.length > 0 ? tags.join('') : '-';
        }

        function updateWorkflowUI() {
            document.querySelectorAll('.workflow-step').forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.remove('active', 'completed');
                step.style.display = '';

                if (stepNum === state.workflowStep) step.classList.add('active');
                else if (stepNum < state.workflowStep) step.classList.add('completed');
            });
            for (let i = 1; i <= 5; i++) document.getElementById(`step-${i}`).classList.toggle('hidden', i !== state.workflowStep);

            // Mettre à jour le label de l'étape 2 selon le type de média
            const step2Label = document.querySelector('.workflow-step[data-step="2"] .step-label');
            if (step2Label) {
                if (state.mediaType === 'ebook') step2Label.textContent = 'Google Books';
                else if (state.mediaType === 'game') step2Label.textContent = 'Steam';
                else step2Label.textContent = 'TMDB';
            }
        }

        async function goToStep(step) {
            state.workflowStep = step;
            updateWorkflowUI();

            if (step === 2) {
                // Configurer l'étape 2 selon le type de média
                const titleEl = document.getElementById('step2Title');
                const labelEl = document.getElementById('step2Label');
                const queryEl = document.getElementById('metadataQuery');
                const resultsEl = document.getElementById('metadataResults');
                const selectedEl = document.getElementById('metadataSelected');

                resultsEl.classList.add('hidden');
                selectedEl.classList.add('hidden');

                if (state.mediaType === 'ebook') {
                    titleEl.textContent = 'Identification Google Books';
                    labelEl.textContent = 'Rechercher sur Google Books';
                    queryEl.placeholder = 'Titre du livre ou auteur...';
                } else if (state.mediaType === 'game') {
                    titleEl.textContent = 'Identification Steam';
                    labelEl.textContent = 'Rechercher sur Steam';
                    queryEl.placeholder = 'Nom du jeu...';
                } else {
                    titleEl.textContent = 'Identification TMDB';
                    labelEl.textContent = 'Rechercher sur TMDB';
                    queryEl.placeholder = 'Titre du film ou serie...';
                }

                // Auto-search si query remplie
                if (queryEl.value && !state.metadataId) searchMetadata();
            } else if (step === 3) {
                const mediaInfoEl = document.getElementById('workflowMediainfo');
                const nfoEl = document.getElementById('nfoContent');

                // Pour les ebooks et jeux, pas de MediaInfo
                if (state.mediaType === 'ebook' || state.mediaType === 'game') {
                    mediaInfoEl.textContent = 'MediaInfo non disponible pour ce type de fichier';
                    nfoEl.value = '';
                    state.nfoContent = '';
                } else {
                    mediaInfoEl.textContent = 'Chargement...';
                    try {
                        const res = await fetch(`${API_BASE}/api/mediainfo?path=${encodeURIComponent(state.selectedFile)}`);
                        const data = await res.json();
                        mediaInfoEl.textContent = data.mediainfo;
                        nfoEl.value = data.mediainfo;
                        state.nfoContent = data.mediainfo;

                        // Re-parse with NFO content for better tag detection
                        const name = state.selectedFile.split('/').pop();
                        const prevGenres = state.releaseInfo ? state.releaseInfo.genres : null;
                        state.releaseInfo = parseReleaseName(name, data.mediainfo);
                        // Preserve genres set from TMDB/metadata at step 2
                        if (prevGenres && prevGenres.length > 0) state.releaseInfo.genres = prevGenres;
                        updateReleaseTags();

                        // Régénérer le nom du torrent avec les infos complètes du NFO
                        const generatedName = generateReleaseName(state.releaseInfo, state.mediaType);
                        if (generatedName) {
                            document.getElementById('torrentName').value = generatedName;
                        }
                    } catch (e) { mediaInfoEl.textContent = 'Erreur: ' + e.message; }
                }
            } else if (step === 4) {
                if (state.settings.torrentTrackers) document.getElementById('trackersInput').value = state.settings.torrentTrackers;
                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.add('hidden');
                // Afficher le nom actuel du fichier
                const originalName = state.selectedFile ? state.selectedFile.split('/').pop() : '-';
                document.getElementById('currentFileName').textContent = originalName;
                // Mettre à jour l'affichage du futur nom
                updateFutureFileName();
            } else if (step === 5) {
                document.getElementById('createdTorrentPath').textContent = state.createdTorrentPath || '-';
                document.getElementById('createdNfoPath').textContent = state.createdNfoPath || '-';
                document.getElementById('previewLoading').style.display = '';
                document.getElementById('previewContent').style.display = 'none';
                document.getElementById('btnFinish').disabled = true;
                document.getElementById('uploadStatus').innerHTML = '';
                loadPreviewData();
            }
        }

        // ============ METADATA SEARCH (TMDB / Google Books / Steam) ============
        async function searchMetadata() {
            const query = document.getElementById('metadataQuery').value;
            if (!query) return;

            if (state.mediaType === 'ebook') {
                await searchGoogleBooks(query);
            } else if (state.mediaType === 'game') {
                await searchSteam(query);
            } else {
                await searchTmdb(query);
            }
        }

        async function searchTmdb(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche TMDB...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            const type = state.mediaType === 'movie' ? 'movie' : 'tv';
            try {
                const res = await fetch(`https://api.themoviedb.org/3/search/${type}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&language=fr-FR`);
                const data = await res.json();

                if (!data.results || data.results.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.results.slice(0, 10).map(item => `
                    <div class="tmdb-item" onclick="selectTmdbItem(${item.id})">
                        <img src="${item.poster_path ? 'https://image.tmdb.org/t/p/w92' + item.poster_path : ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-item-info">
                            <div class="tmdb-item-title">${item.title || item.name}</div>
                            <div class="tmdb-item-year">${(item.release_date || item.first_air_date || '').substring(0, 4)} - ID: ${item.id}</div>
                            <div class="tmdb-item-overview">${item.overview || ''}</div>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }
        }

        async function selectTmdbItem(id) {
            state.metadataId = id.toString();
            state.tmdbId = id.toString();
            const type = state.mediaType === 'movie' ? 'movie' : 'tv';

            try {
                const res = await fetch(`https://api.themoviedb.org/3/${type}/${id}?api_key=${TMDB_API_KEY}&language=fr-FR`);
                state.metadataData = await res.json();
                state.tmdbData = state.metadataData;

                if (state.metadataData.genres) state.releaseInfo.genres = state.metadataData.genres.map(g => g.name);

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');
                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${state.metadataData.poster_path ? 'https://image.tmdb.org/t/p/w154' + state.metadataData.poster_path : ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${state.metadataData.title || state.metadataData.name}</div>
                            <div class="tmdb-selected-meta">${(state.metadataData.release_date || state.metadataData.first_air_date || '').substring(0, 4)} - ${(state.metadataData.genres || []).map(g => g.name).join(', ')}</div>
                            <div class="tmdb-selected-overview">${state.metadataData.overview || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur TMDB: ' + e.message, 'error');
            }
        }

        // ============ GOOGLE BOOKS API ============
        async function searchGoogleBooks(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche Google Books...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            try {
                const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=10&langRestrict=fr`);
                const data = await res.json();

                if (!data.items || data.items.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.items.map(item => {
                    const info = item.volumeInfo || {};
                    const thumbnail = info.imageLinks?.thumbnail || '';
                    const authors = (info.authors || []).join(', ');
                    const year = (info.publishedDate || '').substring(0, 4);
                    return `
                        <div class="tmdb-item" onclick="selectGoogleBook('${item.id}')">
                            <img src="${thumbnail}" alt="" onerror="this.style.display='none'">
                            <div class="tmdb-item-info">
                                <div class="tmdb-item-title">${info.title || 'Sans titre'}</div>
                                <div class="tmdb-item-year">${authors}${year ? ' - ' + year : ''}</div>
                                <div class="tmdb-item-overview">${info.description || ''}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }
        }

        async function selectGoogleBook(id) {
            state.metadataId = id;
            state.bookId = id;

            try {
                const res = await fetch(`https://www.googleapis.com/books/v1/volumes/${id}`);
                const data = await res.json();
                const info = data.volumeInfo || {};
                state.metadataData = info;
                state.bookData = info;

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');

                const thumbnail = info.imageLinks?.thumbnail || info.imageLinks?.smallThumbnail || '';
                const authors = (info.authors || []).join(', ');
                const year = (info.publishedDate || '').substring(0, 4);
                const categories = (info.categories || []).join(', ');

                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${thumbnail}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${info.title || 'Sans titre'}</div>
                            <div class="tmdb-selected-meta">${authors}${year ? ' (' + year + ')' : ''}${categories ? ' - ' + categories : ''}</div>
                            <div class="tmdb-selected-overview">${info.description || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur Google Books: ' + e.message, 'error');
            }
        }

        // ============ STEAM API (via proxy backend) ============
        async function searchSteam(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche Steam...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            try {
                const res = await fetch(`${API_BASE}/api/steam/search?q=${encodeURIComponent(query)}`);
                const data = await res.json();

                if (!data.items || data.items.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.items.slice(0, 10).map(item => `
                    <div class="tmdb-item" onclick="selectSteamGame(${item.id})">
                        <img src="${item.tiny_image || ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-item-info">
                            <div class="tmdb-item-title">${item.name}</div>
                            <div class="tmdb-item-year">Steam ID: ${item.id}</div>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur Steam: ${e.message}</div>`;
            }
        }

        async function selectSteamGame(id) {
            state.metadataId = id.toString();
            state.steamId = id.toString();

            try {
                const res = await fetch(`${API_BASE}/api/steam/details?appid=${id}`);
                const data = await res.json();
                const gameData = data[id]?.data;

                if (!gameData) {
                    showToast('Impossible de charger les details du jeu', 'error');
                    return;
                }

                state.metadataData = gameData;
                state.gameData = gameData;

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');

                const genres = (gameData.genres || []).map(g => g.description).join(', ');
                const releaseDate = gameData.release_date?.date || '';

                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${gameData.header_image || ''}" alt="" style="width:200px;height:auto;" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${gameData.name}</div>
                            <div class="tmdb-selected-meta">${releaseDate}${genres ? ' - ' + genres : ''}</div>
                            <div class="tmdb-selected-overview">${gameData.short_description || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur Steam: ' + e.message, 'error');
            }
        }

        async function createTorrent() {
            const btn = document.getElementById('btnCreateTorrent');
            btn.disabled = true;
            document.getElementById('btnStep4Back').disabled = true;
            document.getElementById('creationProgress').classList.remove('hidden');

            const trackers = document.getElementById('trackersInput').value.split('\n').filter(t => t.trim());
            const isPrivate = document.getElementById('torrentPrivate').checked;
            const torrentName = document.getElementById('torrentName').value;
            const renameFile = document.getElementById('renameFile').checked;
            let nfoContent = document.getElementById('nfoContent').value;

            // Extraire l'extension et le nom original
            const originalName = state.selectedFile.split('/').pop();
            const ext = originalName.match(/\.[^/.]+$/)?.[0] || '';
            const newCompleteName = torrentName + ext;

            // Remplacer le "Complete name" dans le NFO par le nom généré (seulement si renameFile est coché)
            if (torrentName && nfoContent && renameFile) {
                // Remplacer la ligne "Complete name"
                nfoContent = nfoContent.replace(
                    /^(Complete name\s*:\s*).*$/m,
                    `$1${newCompleteName}`
                );
                // Mettre à jour l'affichage
                document.getElementById('nfoContent').value = nfoContent;
            }
            state.nfoContent = nfoContent;

            try {
                // Save NFO with updated name
                const nfoRes = await fetch(`${API_BASE}/api/nfo/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sourcePath: state.selectedFile, content: state.nfoContent, torrentName, mediaType: state.mediaType })
                });
                if (!nfoRes.ok) throw new Error('Erreur sauvegarde NFO: ' + await nfoRes.text());
                const nfoData = await nfoRes.json();
                state.createdNfoPath = nfoData.nfoPath;

                // Create torrent (async with progress)
                const torrentRes = await fetch(`${API_BASE}/api/torrent/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sourcePath: state.selectedFile, trackers, comment: 'AATM', isPrivate, torrentName, mediaType: state.mediaType })
                });
                if (!torrentRes.ok) throw new Error('Erreur creation torrent: ' + await torrentRes.text());
                const { taskId } = await torrentRes.json();

                // Poll for progress
                const progressBar = document.getElementById('creationProgressBar');
                const progressText = document.getElementById('creationProgressText');
                let torrentPath = null;
                while (true) {
                    await new Promise(r => setTimeout(r, 800));
                    const statusRes = await fetch(`${API_BASE}/api/torrent/status/${taskId}`);
                    if (!statusRes.ok) throw new Error('Erreur status torrent: ' + await statusRes.text());
                    const task = await statusRes.json();

                    const pct = Math.round(task.progress * 100);
                    progressBar.style.width = pct + '%';
                    progressBar.textContent = pct + '%';

                    if (task.status === 'hashing') {
                        const hashedMB = (task.hashedBytes / (1024*1024)).toFixed(0);
                        const totalMB = (task.totalBytes / (1024*1024)).toFixed(0);
                        progressText.textContent = `Hachage en cours... ${hashedMB} / ${totalMB} Mo`;
                    } else if (task.status === 'building') {
                        progressText.textContent = 'Construction du fichier torrent...';
                    }

                    if (task.status === 'done') {
                        torrentPath = task.torrentPath;
                        break;
                    }
                    if (task.status === 'error') {
                        throw new Error('Erreur creation torrent: ' + task.error);
                    }
                }
                state.createdTorrentPath = torrentPath;

                // Create hardlink if enabled
                let hardlinkPath = null;
                let hardlinkError = null;
                if (state.settings.enableHardlink && state.settings.hardlinkDirs && state.settings.hardlinkDirs.length > 0) {
                    try {
                        const hardlinkReqBody = {
                            sourcePath: state.selectedFile,
                            hardlinkDirs: state.settings.hardlinkDirs
                        };
                        // Si renameFile est coché, passer le nouveau nom pour le hardlink
                        if (renameFile && torrentName) {
                            hardlinkReqBody.destName = newCompleteName;
                        }
                        const hardlinkRes = await fetch(`${API_BASE}/api/hardlink/create`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(hardlinkReqBody)
                        });
                        if (hardlinkRes.ok) {
                            const hardlinkData = await hardlinkRes.json();
                            hardlinkPath = hardlinkData.hardlinkPath;
                        } else {
                            hardlinkError = await hardlinkRes.text();
                            console.warn('Hardlink creation failed:', hardlinkError);
                        }
                    } catch (hlErr) {
                        hardlinkError = hlErr.message;
                        console.warn('Hardlink creation failed:', hlErr);
                    }
                }

                // Mark processed
                await fetch(`${API_BASE}/api/processed/mark`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: state.selectedFile })
                });

                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.remove('hidden');
                let successMsg = 'Torrent et NFO crees avec succes!';
                if (hardlinkPath) successMsg += `<br><small>Hardlink: ${hardlinkPath}</small>`;
                else if (hardlinkError) successMsg += `<br><small style="color: var(--warning-text);">Hardlink échoué: ${hardlinkError}</small>`;
                else if (state.settings.enableHardlink) successMsg += `<br><small style="color: var(--warning-text);">Hardlink: aucun répertoire configuré sur le même disque</small>`;
                document.getElementById('creationResult').innerHTML = `<div class="alert alert-success">${successMsg}</div>`;
                showToast('Torrent cree!', 'success');
                setTimeout(() => goToStep(5), 5000);
            } catch (e) {
                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.remove('hidden');
                document.getElementById('creationResult').innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
                btn.disabled = false;
                document.getElementById('btnStep4Back').disabled = false;
                showToast('Erreur: ' + e.message, 'error');
            }
        }

        async function uploadToTorrentClient() {
            const statusEl = document.getElementById('uploadStatus');
            // Vider la zone au début du workflow d'upload
            statusEl.innerHTML = '';
            const clientName = state.settings.torrentClient || 'qbittorrent';
            if (clientName === 'none') {
                statusEl.innerHTML = '<div class="alert alert-info">Aucun client torrent configure - etape ignoree</div>';
                return;
            }
            const clientDisplayNames = {
                'qbittorrent': 'qBittorrent',
                'transmission': 'Transmission',
                'deluge': 'Deluge'
            };
            const displayName = clientDisplayNames[clientName] || clientName;
            // Créer un élément dédié pour le statut du client torrent
            const clientDiv = document.createElement('div');
            clientDiv.innerHTML = `<div class="loading"><div class="spinner"></div>Upload vers ${displayName}...</div>`;
            statusEl.appendChild(clientDiv);
            try {
                const res = await fetch(`${API_BASE}/api/torrent-client/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        torrentPath: state.createdTorrentPath
                    })
                });
                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(errText || `Erreur upload ${displayName}`);
                }
                clientDiv.innerHTML = `<div class="alert alert-success">Upload ${displayName} reussi!</div>`;
                showToast(`Upload ${displayName} OK!`, 'success');
            } catch (e) {
                clientDiv.innerHTML = `<div class="alert alert-danger">Erreur ${displayName}: ${e.message}</div>`;
                showToast('Erreur: ' + e.message, 'error');
            }
        }

        // Alias pour compatibilite
        async function uploadToQBittorrent() {
            return uploadToTorrentClient();
        }

        async function uploadToLaCale() {
            const statusEl = document.getElementById('uploadStatus');
            // Ajouter un élément dédié pour La-Cale (sans écraser le résultat du client torrent)
            const laCaleDiv = document.createElement('div');
            laCaleDiv.style.marginTop = '0.5rem';
            laCaleDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Upload La-Cale en cours...</div>';
            statusEl.appendChild(laCaleDiv);

            try {
                // Read values from preview fields (user may have modified them)
                const title = document.getElementById('previewTitle').value || document.getElementById('torrentName').value || state.selectedFile.split('/').pop();
                const description = document.getElementById('previewDescription').value || '';
                const selectedTags = getSelectedTagIds();

                const res = await fetch(`${API_BASE}/api/lacale/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        torrentPath: state.createdTorrentPath,
                        nfoPath: state.createdNfoPath,
                        title: title,
                        description: description,
                        tmdbId: state.tmdbId,
                        mediaType: state.mediaType,
                        releaseInfo: state.releaseInfo,
                        passkey: state.settings.passkey,
                        apiKey: state.settings.laCaleApiKey,
                        tags: selectedTags
                    })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(errText || 'Erreur upload La-Cale');
                }

                laCaleDiv.innerHTML = '<div class="alert alert-success">Upload La-Cale reussi!</div>';
                showToast('Upload La-Cale OK!', 'success');
                return true;
            } catch (e) {
                laCaleDiv.innerHTML = `<div class="alert alert-danger">Erreur upload La-Cale : ${e.message}</div>`;
                showToast('Erreur La-Cale: ' + e.message, 'error');
                return false;
            }
        }

        async function loadPreviewData() {
            // Afficher le contenu immédiatement, masquer le chargement
            document.getElementById('previewLoading').style.display = 'none';
            document.getElementById('previewContent').style.display = 'block';
            document.getElementById('btnFinish').disabled = true;

            // Titre
            try {
                const torrentEl = document.getElementById('torrentName');
                const torrentName = (torrentEl && torrentEl.value) ||
                    (state.selectedFile ? state.selectedFile.split('/').pop() : '');
                document.getElementById('previewTitle').value = torrentName;
            } catch (e) { console.error('previewTitle error:', e); }

            // Taille totale
            let totalSize = null;
            try {
                const sizeRes = await fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(state.selectedFile)}`);
                const sizeData = await sizeRes.json();
                totalSize = sizeData.size;
            } catch (e) {}

            // Description BBCode (génération indépendante)
            let description = '';
            try {
                description = await generatePresentation({
                    releaseInfo: state.releaseInfo,
                    tmdbId: state.tmdbId,
                    mediaType: state.mediaType,
                    nfoContent: state.nfoContent,
                    totalSize
                });
            } catch (e) {
                console.error('generatePresentation error:', e);
            }
            document.getElementById('previewDescription').value = description || '';
            updateBbcodePreview();

            // Preview La-Cale (catégorie + tags, indépendant)
            let previewData = null;
            try {
                const previewRes = await fetch(`${API_BASE}/api/lacale/preview`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        mediaType: state.mediaType,
                        releaseInfo: state.releaseInfo,
                        apiKey: state.settings.laCaleApiKey
                    })
                });
                if (previewRes.ok) {
                    previewData = await previewRes.json();
                } else {
                    console.warn('preview API:', previewRes.status, await previewRes.text());
                }
            } catch (e) {
                console.error('preview API error:', e);
            }
            state.previewData = previewData;

            // Catégorie
            document.getElementById('previewCategory').textContent =
                (previewData && previewData.categoryName) ? previewData.categoryName : 'Non detectee';

            // Tags
            renderTagGroups(previewData);

            // Activer le bouton upload
            document.getElementById('btnFinish').disabled = false;
        }

        function bbcodeToHtml(text) {
            if (!text) return '';
            let h = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            h = h.replace(/\[b\]([\s\S]*?)\[\/b\]/gi, '<strong>$1</strong>');
            h = h.replace(/\[i\]([\s\S]*?)\[\/i\]/gi, '<em>$1</em>');
            h = h.replace(/\[u\]([\s\S]*?)\[\/u\]/gi, '<u>$1</u>');
            h = h.replace(/\[center\]([\s\S]*?)\[\/center\]/gi, '<div style="text-align:center">$1</div>');
            h = h.replace(/\[img\]([\s\S]*?)\[\/img\]/gi, '<img src="$1" alt="">');
            h = h.replace(/\[url=([^\]]+)\]([\s\S]*?)\[\/url\]/gi, '<a href="$1" target="_blank" rel="noopener">$2</a>');
            h = h.replace(/\[url\]([\s\S]*?)\[\/url\]/gi, '<a href="$1" target="_blank" rel="noopener">$1</a>');
            h = h.replace(/\[quote\]([\s\S]*?)\[\/quote\]/gi, '<div class="bbcode-quote">$1</div>');
            h = h.replace(/\[size=(\d+)\]([\s\S]*?)\[\/size\]/gi, (_, sz, ct) => {
                const px = Math.min(Math.max(parseInt(sz) * 4, 10), 40);
                return `<span style="font-size:${px}px">${ct}</span>`;
            });
            h = h.replace(/\[color=([^\]]+)\]([\s\S]*?)\[\/color\]/gi, (_, cl, ct) => `<span style="color:${cl}">${ct}</span>`);
            h = h.replace(/\n/g, '<br>');
            return h;
        }

        function switchBbcodeTab(tab, el) {
            document.querySelectorAll('.bbcode-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.bbcode-tab-content').forEach(t => t.classList.remove('active'));
            el.classList.add('active');
            document.getElementById(tab === 'source' ? 'bbcodeTabSource' : 'bbcodeTabRender').classList.add('active');
            if (tab === 'render') updateBbcodePreview();
        }

        function updateBbcodePreview() {
            const text = document.getElementById('previewDescription').value;
            document.getElementById('bbcodePreviewRender').innerHTML = bbcodeToHtml(text);
        }

        function renderTagGroups(previewData) {
            const container = document.getElementById('previewTags');
            if (!previewData || !previewData.allTagGroups || previewData.allTagGroups.length === 0) {
                container.innerHTML = '<span style="color:var(--text-muted)">Aucun tag disponible</span>';
                return;
            }

            // Build set of matched tag IDs
            const matchedIds = new Set();
            if (previewData.matchedTags) {
                previewData.matchedTags.forEach(t => matchedIds.add(t.id));
            }

            let html = '';
            for (const group of previewData.allTagGroups) {
                if (!group.tags || group.tags.length === 0) continue;
                html += `<div class="tag-group">`;
                html += `<div class="tag-group-title">${group.name}</div>`;
                html += `<div class="tag-chips">`;
                for (const tag of group.tags) {
                    const selected = matchedIds.has(tag.id) ? ' selected' : '';
                    html += `<span class="tag-chip${selected}" data-tag-id="${tag.id}" onclick="toggleTag(this)">${tag.name}</span>`;
                }
                html += `</div></div>`;
            }
            container.innerHTML = html;
        }

        function toggleTag(el) {
            el.classList.toggle('selected');
        }

        function getSelectedTagIds() {
            const chips = document.querySelectorAll('#previewTags .tag-chip.selected');
            return Array.from(chips).map(c => c.dataset.tagId);
        }

        async function finishWorkflow(skipLaCale = false) {
            const btn = document.getElementById('btnFinish');
            btn.disabled = true;
            btn.textContent = 'Upload en cours...';

            // Upload to torrent client first (qBittorrent, Transmission, Deluge)
            await uploadToTorrentClient();

            // Upload to La-Cale (unless skipped)
            let laCaleOk = true;
            if (!skipLaCale) {
                laCaleOk = await uploadToLaCale();
            }

            if (!laCaleOk) {
                // Upload La-Cale échoué : rester sur l'étape 5, informer l'utilisateur
                btn.disabled = false;
                btn.textContent = 'Réessayer l\'upload';
                const statusEl = document.getElementById('uploadStatus');
                const torrentPath = state.createdTorrentPath || '-';
                const nfoPath = state.createdNfoPath || '-';
                const warningDiv = document.createElement('div');
                warningDiv.style.marginTop = '0.5rem';
                warningDiv.innerHTML = `<div class="alert alert-warning">
                    <strong>Fichiers locaux créés avec succès :</strong><br>
                    Torrent : <code>${torrentPath}</code><br>
                    NFO : <code>${nfoPath}</code><br>
                    <button class="btn btn-secondary" onclick="finishWorkflow(true)" style="margin-top:0.5rem;">Terminer sans upload La-Cale</button>
                </div>`;
                statusEl.appendChild(warningDiv);
                return;
            }

            // Reset state
            state.selectedFile = null;
            state.createdTorrentPath = null;
            state.createdNfoPath = null;
            state.workflowStep = 1;
            state.metadataId = '';
            state.metadataData = null;
            state.tmdbId = '';
            state.tmdbData = null;
            state.bookId = '';
            state.bookData = null;
            state.steamId = '';
            state.gameData = null;
            state.previewData = null;
            navigateTo('files');
            showToast('Workflow termine!', 'success');
        }

        async function loadSettings() {
            try {
                const res = await fetch(`${API_BASE}/api/settings`);
                if (res.ok) {
                    state.settings = await res.json();
                    if (!state.settings.rootPath) state.settings.rootPath = '/media';
                    state.currentPath = state.settings.rootPath;
                    loadFiles(state.currentPath);
                }
            } catch (e) { loadFiles('/media'); }
        }

        function loadSettingsForm() {
            document.getElementById('settingRootPath').value = state.settings.rootPath || '/media';
            document.getElementById('settingOutputDir').value = state.settings.outputDir || '/torrents';
            document.getElementById('settingTrackers').value = state.settings.torrentTrackers || '';
            // Torrent client selection
            document.getElementById('settingTorrentClient').value = state.settings.torrentClient || 'qbittorrent';
            // qBittorrent
            document.getElementById('settingQbitUrl').value = state.settings.qbitUrl || 'http://localhost:8081';
            document.getElementById('settingQbitUsername').value = state.settings.qbitUsername || 'admin';
            document.getElementById('settingQbitPassword').value = state.settings.qbitPassword || '';
            // Transmission
            document.getElementById('settingTransmissionUrl').value = state.settings.transmissionUrl || 'http://localhost:9091';
            document.getElementById('settingTransmissionUsername').value = state.settings.transmissionUsername || '';
            document.getElementById('settingTransmissionPassword').value = state.settings.transmissionPassword || '';
            // Deluge
            document.getElementById('settingDelugeUrl').value = state.settings.delugeUrl || 'http://localhost:8112';
            document.getElementById('settingDelugePassword').value = state.settings.delugePassword || 'deluge';
            // La-Cale
            document.getElementById('settingLaCalePasskey').value = state.settings.passkey || '';
            document.getElementById('settingLaCaleApiKey').value = state.settings.laCaleApiKey || '';
            document.getElementById('settingEnableHardlink').checked = state.settings.enableHardlink || false;
            document.getElementById('settingHardlinkDirs').value = (state.settings.hardlinkDirs || []).join('\n');
            document.getElementById('settingShowProcessed').checked = state.settings.showProcessed || false;
            // Toggle visibility
            toggleTorrentClientSettings();
        }

        function toggleTorrentClientSettings() {
            const client = document.getElementById('settingTorrentClient').value;
            document.getElementById('qbittorrentSettings').style.display = client === 'qbittorrent' ? 'block' : 'none';
            document.getElementById('transmissionSettings').style.display = client === 'transmission' ? 'block' : 'none';
            document.getElementById('delugeSettings').style.display = client === 'deluge' ? 'block' : 'none';
        }

        async function saveSettings() {
            const hardlinkDirsText = document.getElementById('settingHardlinkDirs').value;
            const hardlinkDirs = hardlinkDirsText.split('\n').map(s => s.trim()).filter(s => s !== '');

            const settings = {
                rootPath: document.getElementById('settingRootPath').value,
                outputDir: document.getElementById('settingOutputDir').value || '/torrents',
                torrentTrackers: document.getElementById('settingTrackers').value,
                // Torrent client
                torrentClient: document.getElementById('settingTorrentClient').value,
                // qBittorrent
                qbitUrl: document.getElementById('settingQbitUrl').value,
                qbitUsername: document.getElementById('settingQbitUsername').value,
                qbitPassword: document.getElementById('settingQbitPassword').value,
                // Transmission
                transmissionUrl: document.getElementById('settingTransmissionUrl').value,
                transmissionUsername: document.getElementById('settingTransmissionUsername').value,
                transmissionPassword: document.getElementById('settingTransmissionPassword').value,
                // Deluge
                delugeUrl: document.getElementById('settingDelugeUrl').value,
                delugePassword: document.getElementById('settingDelugePassword').value,
                // La-Cale
                passkey: document.getElementById('settingLaCalePasskey').value,
                laCaleApiKey: document.getElementById('settingLaCaleApiKey').value,
                enableHardlink: document.getElementById('settingEnableHardlink').checked,
                hardlinkDirs: hardlinkDirs,
                showProcessed: document.getElementById('settingShowProcessed').checked
            };
            try {
                const res = await fetch(`${API_BASE}/api/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                if (!res.ok) throw new Error('Erreur sauvegarde');
                state.settings = settings;
                state.currentPath = settings.rootPath;
                showToast('Parametres sauvegardes!', 'success');
            } catch (e) { showToast('Erreur: ' + e.message, 'error'); }
        }

        async function loadHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';
            try {
                const res = await fetch(`${API_BASE}/api/processed`);
                const files = await res.json();
                historyList.innerHTML = (!files || files.length === 0)
                    ? '<div class="empty-state"><p>Aucun fichier traite</p></div>'
                    : files.map(file => `<div class="history-item"><span class="history-path">${file.path}</span><span style="color:var(--text-muted);font-size:0.8rem;margin-left:1rem;">${file.processedAt}</span></div>`).join('');
            } catch (e) { historyList.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`; }
        }

        async function clearHistory() {
            if (!confirm('Voulez-vous vraiment effacer tout l\'historique?')) return;
            try {
                await fetch(`${API_BASE}/api/processed`, { method: 'DELETE' });
                showToast('Historique efface!', 'success');
                loadHistory();
            } catch (e) { showToast('Erreur: ' + e.message, 'error'); }
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateFutureFileName() {
            const renameCheckbox = document.getElementById('renameFile');
            const torrentName = document.getElementById('torrentName').value;
            const futureRow = document.getElementById('futureFileNameRow');
            const futureNameEl = document.getElementById('futureFileName');

            if (renameCheckbox && renameCheckbox.checked && torrentName) {
                const originalName = state.selectedFile ? state.selectedFile.split('/').pop() : '';
                const ext = originalName.match(/\.[^/.]+$/)?.[0] || '';
                futureNameEl.textContent = torrentName + ext;
                futureRow.style.display = '';
            } else {
                futureRow.style.display = 'none';
            }
        }

        // Event listeners pour mise à jour du futur nom de fichier
        document.getElementById('renameFile')?.addEventListener('change', updateFutureFileName);
        document.getElementById('torrentName')?.addEventListener('input', updateFutureFileName);

        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;color:var(--${type === 'success' ? 'success-text' : 'danger-text'});">
                    ${type === 'success' ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>' : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'}
                </svg>
                <span>${message}</span>
            `;
            container.appendChild(toast);
            setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 3000);
        }
    </script>
</body>
</html>
