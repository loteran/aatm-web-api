<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AATM - Amazing Automatic Torrent Maker</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M25 15 L25 55 Q25 75 45 75 L45 85 Q15 85 15 55 L15 15 Z' fill='%231a1a4e'/%3E%3Cpath d='M75 15 L75 55 Q75 75 55 75 L55 85 Q85 85 85 55 L85 15 Z' fill='%231a1a4e'/%3E%3Crect x='15' y='10' width='15' height='15' rx='2' fill='%23c0c0c0'/%3E%3Crect x='70' y='10' width='15' height='15' rx='2' fill='%23c0c0c0'/%3E%3Cellipse cx='50' cy='50' rx='8' ry='12' fill='%2300d9ff' opacity='0.6'/%3E%3C/svg%3E">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --bg-hover: #1f2847;
            --accent: #00d9ff;
            --accent-dim: #0099b3;
            --text-primary: #eee;
            --text-secondary: #888;
            --text-muted: #555;
            --success: #0f5132;
            --success-text: #75b798;
            --warning: #664d03;
            --warning-text: #ffda6a;
            --danger: #842029;
            --danger-text: #ea868f;
            --border: #2a2a4a;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
        }
        .app-container { display: flex; height: 100vh; }
        .sidebar {
            width: 220px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header { padding: 1.5rem 1rem; border-bottom: 1px solid var(--border); }
        .sidebar-header h1 { color: var(--accent); font-size: 1.3rem; font-weight: 600; }
        .sidebar-header .subtitle { color: var(--text-secondary); font-size: 0.75rem; }
        .nav-menu { flex: 1; padding: 1rem 0; }
        .nav-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1.25rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .nav-item:hover { background: var(--bg-hover); color: var(--text-primary); }
        .nav-item.active { background: var(--bg-tertiary); color: var(--accent); border-left-color: var(--accent); }
        .nav-item svg { width: 20px; height: 20px; margin-right: 0.75rem; }
        .api-status { padding: 1rem; border-top: 1px solid var(--border); font-size: 0.8rem; }
        .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 0.5rem; }
        .status-indicator.online { background: var(--success-text); box-shadow: 0 0 6px var(--success-text); }
        .status-indicator.offline { background: var(--danger-text); }
        .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .header {
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header h2 { color: var(--text-primary); font-size: 1.2rem; font-weight: 500; }
        .content-area { flex: 1; overflow: auto; padding: 1.5rem; }
        .explorer-container { display: grid; grid-template-columns: 1fr 400px; gap: 1.5rem; height: 100%; }
        .file-browser { background: var(--bg-secondary); border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        .breadcrumb {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .breadcrumb-item { color: var(--text-secondary); cursor: pointer; font-size: 0.9rem; }
        .breadcrumb-item:hover { color: var(--accent); }
        .breadcrumb-item.current { color: var(--text-primary); }
        .breadcrumb-separator { color: var(--text-muted); }
        .file-list { flex: 1; overflow-y: auto; }
        .file-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .file-item:hover { background: var(--bg-hover); }
        .file-item.selected { background: var(--bg-tertiary); border-left: 3px solid var(--accent); }
        .file-item.processed { opacity: 0.5; }
        .file-icon { width: 24px; height: 24px; margin-right: 0.75rem; color: var(--text-secondary); }
        .file-icon.folder { color: var(--warning-text); }
        .file-icon.video { color: var(--accent); }
        .file-icon.ebook { color: #a78bfa; }
        .file-icon.game { color: #10b981; }
        .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .file-size { color: var(--text-secondary); font-size: 0.85rem; margin-left: 1rem; }
        .processed-badge { background: var(--success); color: var(--success-text); font-size: 0.7rem; padding: 0.15rem 0.5rem; border-radius: 3px; margin-left: 0.5rem; }
        .details-panel { background: var(--bg-secondary); border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        .details-header { padding: 1rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border); }
        .details-header h3 { font-size: 1rem; font-weight: 500; }
        .details-content { flex: 1; overflow-y: auto; padding: 1rem; }
        .detail-section { margin-bottom: 1.5rem; }
        .detail-section h4 { color: var(--accent); font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.75rem; }
        .mediainfo-output { background: var(--bg-primary); border-radius: 4px; padding: 1rem; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.75rem; white-space: pre-wrap; max-height: 400px; overflow-y: auto; color: var(--text-secondary); }
        .detail-row { display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid var(--border); }
        .detail-row:last-child { border-bottom: none; }
        .detail-label { color: var(--text-secondary); }
        .detail-value { color: var(--text-primary); font-weight: 500; }
        .action-buttons { padding: 1rem; border-top: 1px solid var(--border); display: flex; gap: 0.75rem; }
        .btn { padding: 0.6rem 1rem; border: none; border-radius: 6px; font-size: 0.85rem; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.5rem; }
        .btn svg { width: 16px; height: 16px; }
        .btn-primary { background: var(--accent); color: var(--bg-primary); font-weight: 500; }
        .btn-primary:hover { background: var(--accent-dim); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--bg-hover); }
        .btn-danger { background: var(--danger); color: var(--danger-text); }
        .btn-success { background: var(--success); color: var(--success-text); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-sm { padding: 0.4rem 0.75rem; font-size: 0.8rem; }
        .btn-full { width: 100%; justify-content: center; }
        .workflow-container { max-width: 1000px; margin: 0 auto; }
        .workflow-steps { display: flex; margin-bottom: 2rem; padding: 0 1rem; }
        .workflow-step { flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; }
        .workflow-step::after { content: ''; position: absolute; top: 15px; left: 50%; width: 100%; height: 2px; background: var(--border); }
        .workflow-step:last-child::after { display: none; }
        .step-number { width: 30px; height: 30px; border-radius: 50%; background: var(--bg-tertiary); border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-size: 0.85rem; font-weight: 600; z-index: 1; transition: all 0.3s; }
        .workflow-step.active .step-number { background: var(--accent); border-color: var(--accent); color: var(--bg-primary); }
        .workflow-step.completed .step-number { background: var(--success); border-color: var(--success-text); color: var(--success-text); }
        .step-label { margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary); }
        .workflow-step.active .step-label { color: var(--accent); }
        .workflow-content { background: var(--bg-secondary); border-radius: 8px; padding: 1.5rem; }
        .workflow-title { font-size: 1.1rem; margin-bottom: 1rem; }
        .workflow-actions { display: flex; justify-content: space-between; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); }
        .form-group { margin-bottom: 1rem; }
        .form-group label { display: block; color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.5rem; }
        .form-control { width: 100%; padding: 0.6rem 0.75rem; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 0.9rem; }
        .form-control:focus { outline: none; border-color: var(--accent); }
        textarea.form-control { min-height: 150px; resize: vertical; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.8rem; }
        .form-check { display: flex; align-items: center; gap: 0.5rem; }
        .form-check input { width: 16px; height: 16px; accent-color: var(--accent); }
        .settings-container { max-width: 700px; margin: 0 auto; }
        .settings-section { background: var(--bg-secondary); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; }
        .settings-section h3 { color: var(--accent); font-size: 1rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border); }
        .history-container { max-width: 800px; margin: 0 auto; }
        .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        .history-list { background: var(--bg-secondary); border-radius: 8px; }
        .history-item { padding: 1rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
        .history-item:last-child { border-bottom: none; }
        .history-path { font-family: monospace; font-size: 0.85rem; color: var(--text-secondary); }
        .alert { padding: 1rem; border-radius: 6px; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem; }
        .alert-success { background: var(--success); color: var(--success-text); }
        .alert-danger { background: var(--danger); color: var(--danger-text); }
        .alert-warning { background: var(--warning); color: var(--warning-text); }
        .loading { display: flex; align-items: center; justify-content: center; padding: 2rem; color: var(--text-secondary); }
        .spinner { width: 24px; height: 24px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-right: 0.75rem; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .empty-state { text-align: center; padding: 3rem; color: var(--text-secondary); }
        .empty-state svg { width: 64px; height: 64px; margin-bottom: 1rem; opacity: 0.5; }
        .hidden { display: none !important; }
        .toast-container { position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 1000; }
        .toast { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 1rem 1.25rem; margin-top: 0.75rem; display: flex; align-items: center; gap: 0.75rem; animation: slideIn 0.3s ease; max-width: 400px; }
        .toast.success { border-color: var(--success-text); }
        .toast.error { border-color: var(--danger-text); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        @media (max-width: 1024px) { .explorer-container { grid-template-columns: 1fr; } .details-panel { max-height: 400px; } }
        @media (max-width: 768px) { .sidebar { width: 60px; } .sidebar-header h1, .sidebar-header .subtitle, .nav-item span, .api-status span { display: none; } .nav-item { justify-content: center; padding: 1rem; } .nav-item svg { margin-right: 0; } }

        /* New styles for TMDB and tags */
        .tag { display: inline-block; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; font-size: 0.75rem; margin: 0.15rem; }
        .tag.resolution { color: #10b981; border-color: #10b981; }
        .tag.codec { color: #f472b6; border-color: #f472b6; }
        .tag.audio { color: #fb923c; border-color: #fb923c; }
        .tag.language { color: #ef4444; border-color: #ef4444; }
        .tag.source { color: #a78bfa; border-color: #a78bfa; }
        .tag.hdr { color: #22d3ee; border-color: #22d3ee; }
        .tag.year { color: #60a5fa; border-color: #60a5fa; }
        .tag.group { color: #9ca3af; border-color: #9ca3af; }
        .tmdb-results { max-height: 300px; overflow-y: auto; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; margin-top: 0.5rem; }
        .tmdb-item { display: flex; gap: 1rem; padding: 0.75rem; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
        .tmdb-item:hover { background: var(--bg-hover); }
        .tmdb-item:last-child { border-bottom: none; }
        .tmdb-item img { width: 50px; height: 75px; object-fit: cover; border-radius: 4px; background: var(--bg-tertiary); }
        .tmdb-item-info { flex: 1; }
        .tmdb-item-title { font-weight: 500; color: var(--text-primary); }
        .tmdb-item-year { font-size: 0.8rem; color: var(--text-secondary); }
        .tmdb-item-overview { font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
        .tmdb-selected { display: flex; gap: 1rem; padding: 1rem; background: var(--bg-tertiary); border: 1px solid var(--success-text); border-radius: 6px; margin-top: 0.5rem; }
        .tmdb-selected img { width: 80px; height: 120px; object-fit: cover; border-radius: 4px; }
        .tmdb-selected-info { flex: 1; }
        .tmdb-selected-title { font-weight: 600; color: var(--text-primary); font-size: 1.1rem; }
        .tmdb-selected-meta { font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem; }
        .tmdb-selected-overview { font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem; }
        .media-type-selector { display: flex; gap: 1rem; margin-bottom: 1rem; }
        .media-type-btn { flex: 1; padding: 1rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s; }
        .media-type-btn:hover { border-color: var(--accent); }
        .media-type-btn.active { border-color: var(--accent); background: var(--bg-hover); }
        .media-type-btn svg { width: 32px; height: 32px; margin-bottom: 0.5rem; color: var(--text-secondary); }
        .media-type-btn.active svg { color: var(--accent); }
        .media-type-btn span { display: block; font-size: 0.85rem; color: var(--text-secondary); }
        .media-type-btn.active span { color: var(--text-primary); }
        .release-tags { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-top: 0.5rem; }
        .search-row { display: flex; gap: 0.5rem; }
        .search-row input { flex: 1; }
    </style>
</head>
<body>
    <div class="app-container">
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1>AATM</h1>
                <p class="subtitle">Torrent Maker</p>
            </div>
            <div class="nav-menu">
                <div class="nav-item active" data-page="files">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
                    <span>Explorateur</span>
                </div>
                <div class="nav-item" data-page="create">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
                    <span>Creer Torrent</span>
                </div>
                <div class="nav-item" data-page="settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                    <span>Parametres</span>
                </div>
                <div class="nav-item" data-page="history">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                    <span>Historique</span>
                </div>
            </div>
            <div class="api-status">
                <span class="status-indicator online" id="statusIndicator"></span>
                <span id="statusText">API en ligne</span>
            </div>
        </nav>

        <main class="main-content">
            <header class="header">
                <h2 id="pageTitle">Explorateur de fichiers</h2>
                <div id="headerActions"></div>
            </header>

            <div class="content-area">
                <!-- Files Page -->
                <div id="page-files" class="page">
                    <div class="explorer-container">
                        <div class="file-browser">
                            <div style="display:flex;align-items:center;gap:1rem;margin-bottom:0.5rem;">
                                <div class="breadcrumb" id="breadcrumb" style="flex:1;margin-bottom:0;"><span class="breadcrumb-item current">/</span></div>
                                <button class="btn btn-primary btn-sm" id="btnCreateFromFolder" title="Creer un torrent de ce dossier">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                                    Torrent du dossier
                                </button>
                            </div>
                            <div class="file-list" id="fileList"><div class="loading"><div class="spinner"></div>Chargement...</div></div>
                        </div>
                        <div class="details-panel">
                            <div class="details-header"><h3 id="detailsTitle">Details</h3></div>
                            <div class="details-content" id="detailsContent">
                                <div class="empty-state">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                                    <p>Selectionnez un fichier pour voir ses details</p>
                                </div>
                            </div>
                            <div class="action-buttons" id="fileActions" style="display:none;">
                                <button class="btn btn-primary btn-full" id="btnStartWorkflow">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>
                                    Creer un torrent
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Create Workflow Page -->
                <div id="page-create" class="page hidden">
                    <div class="workflow-container">
                        <div class="workflow-steps">
                            <div class="workflow-step active" data-step="1"><div class="step-number">1</div><div class="step-label">Type</div></div>
                            <div class="workflow-step" data-step="2"><div class="step-number">2</div><div class="step-label">TMDB</div></div>
                            <div class="workflow-step" data-step="3"><div class="step-number">3</div><div class="step-label">NFO</div></div>
                            <div class="workflow-step" data-step="4"><div class="step-number">4</div><div class="step-label">Torrent</div></div>
                            <div class="workflow-step" data-step="5"><div class="step-number">5</div><div class="step-label">Upload</div></div>
                        </div>

                        <!-- Step 1: Type Selection -->
                        <div class="workflow-content" id="step-1">
                            <h3 class="workflow-title">Selection du type de media</h3>
                            <div id="selectedSource"></div>
                            <div class="media-type-selector" id="mediaTypeSelector">
                                <div class="media-type-btn" data-type="movie">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg>
                                    <span>Film</span>
                                </div>
                                <div class="media-type-btn" data-type="episode">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>
                                    <span>Episode</span>
                                </div>
                                <div class="media-type-btn" data-type="season">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                                    <span>Saison</span>
                                </div>
                                <div class="media-type-btn" data-type="ebook">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
                                    <span>E-book</span>
                                </div>
                                <div class="media-type-btn" data-type="game">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12" rx="2"/><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><circle cx="17" cy="10" r="1"/><circle cx="15" cy="13" r="1"/></svg>
                                    <span>Jeu video</span>
                                </div>
                            </div>
                            <div class="detail-section" style="margin-top:1rem;">
                                <h4>Tags detectes</h4>
                                <div class="release-tags" id="releaseTags">-</div>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="navigateTo('files')">Choisir un fichier</button>
                                <button class="btn btn-primary" id="btnStep1Next" disabled>Suivant</button>
                            </div>
                        </div>

                        <!-- Step 2: Metadata Search (TMDB / Google Books / Steam) -->
                        <div class="workflow-content hidden" id="step-2">
                            <h3 class="workflow-title" id="step2Title">Identification</h3>
                            <div class="form-group">
                                <label id="step2Label">Rechercher</label>
                                <div class="search-row">
                                    <input type="text" class="form-control" id="metadataQuery" placeholder="Rechercher...">
                                    <button class="btn btn-primary" id="btnMetadataSearch">Rechercher</button>
                                </div>
                                <div id="metadataResults" class="tmdb-results hidden"></div>
                                <div id="metadataSelected" class="hidden"></div>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(1)">Precedent</button>
                                <button class="btn btn-primary" id="btnStep2Next" disabled>Suivant</button>
                            </div>
                        </div>

                        <!-- Step 3: NFO -->
                        <div class="workflow-content hidden" id="step-3">
                            <h3 class="workflow-title">MediaInfo et NFO</h3>
                            <div class="form-group">
                                <label>Apercu MediaInfo</label>
                                <div class="mediainfo-output" id="workflowMediainfo">Chargement...</div>
                            </div>
                            <div class="form-group">
                                <label>Contenu NFO (editable)</label>
                                <textarea class="form-control" id="nfoContent" placeholder="Le contenu MediaInfo sera copie ici..."></textarea>
                            </div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(2)">Precedent</button>
                                <button class="btn btn-primary" onclick="goToStep(4)">Suivant</button>
                            </div>
                        </div>

                        <!-- Step 4: Torrent Config -->
                        <div class="workflow-content hidden" id="step-4">
                            <h3 class="workflow-title">Configuration du torrent</h3>
                            <div class="form-group">
                                <label>Nom du torrent</label>
                                <input type="text" class="form-control" id="torrentName" placeholder="Nom du fichier torrent">
                            </div>
                            <div class="form-group">
                                <label>Trackers (un par ligne)</label>
                                <textarea class="form-control" id="trackersInput" rows="4" placeholder="http://tracker.example.com/announce"></textarea>
                            </div>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="torrentPrivate" checked>
                                    <label for="torrentPrivate">Torrent prive</label>
                                </div>
                            </div>
                            <div id="creationProgress" class="hidden"><div class="loading"><div class="spinner"></div>Creation en cours...</div></div>
                            <div id="creationResult" class="hidden"></div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(3)" id="btnStep4Back">Precedent</button>
                                <button class="btn btn-primary" id="btnCreateTorrent">Creer le torrent</button>
                            </div>
                        </div>

                        <!-- Step 5: Upload -->
                        <div class="workflow-content hidden" id="step-5">
                            <h3 class="workflow-title">Upload</h3>
                            <div class="detail-section">
                                <h4>Fichiers crees</h4>
                                <div class="detail-row"><span class="detail-label">Torrent</span><span class="detail-value" id="createdTorrentPath">-</span></div>
                                <div class="detail-row"><span class="detail-label">NFO</span><span class="detail-value" id="createdNfoPath">-</span></div>
                            </div>
                            <div id="uploadStatus" style="margin-top: 1rem;"></div>
                            <div class="workflow-actions">
                                <button class="btn btn-secondary" onclick="goToStep(4)">Precedent</button>
                                <button class="btn btn-success" id="btnFinish">Terminer et uploader sur La-Cale</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div id="page-settings" class="page hidden">
                    <div class="settings-container">
                        <div class="settings-section">
                            <h3>Chemins</h3>
                            <div class="form-group">
                                <label>Chemin racine des medias</label>
                                <input type="text" class="form-control" id="settingRootPath" placeholder="/media">
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Trackers par defaut</h3>
                            <div class="form-group">
                                <label>Liste des trackers (un par ligne)</label>
                                <textarea class="form-control" id="settingTrackers" rows="4"></textarea>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>qBittorrent</h3>
                            <div class="form-group"><label>URL</label><input type="text" class="form-control" id="settingQbitUrl" placeholder="http://localhost:8080"></div>
                            <div class="form-group"><label>Nom d'utilisateur</label><input type="text" class="form-control" id="settingQbitUsername" placeholder="admin"></div>
                            <div class="form-group"><label>Mot de passe</label><input type="password" class="form-control" id="settingQbitPassword"></div>
                        </div>
                        <div class="settings-section">
                            <h3>La-Cale</h3>
                            <div class="form-group"><label>Email</label><input type="email" class="form-control" id="settingLaCaleEmail"></div>
                            <div class="form-group"><label>Mot de passe</label><input type="password" class="form-control" id="settingLaCalePassword"></div>
                            <div class="form-group"><label>Passkey</label><input type="text" class="form-control" id="settingLaCalePasskey"></div>
                        </div>
                        <div class="settings-section">
                            <h3>Hardlinks</h3>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="settingEnableHardlink">
                                    <label for="settingEnableHardlink">Activer la creation de hardlinks</label>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Repertoires de destination (un par ligne, un par disque)</label>
                                <textarea class="form-control" id="settingHardlinkDirs" rows="3" placeholder="/mnt/disk1/torrents&#10;/mnt/disk2/torrents"></textarea>
                                <small style="color:var(--text-muted);">Le repertoire sur le meme disque que la source sera automatiquement selectionne</small>
                            </div>
                        </div>
                        <div class="settings-section">
                            <h3>Affichage</h3>
                            <div class="form-group">
                                <div class="form-check">
                                    <input type="checkbox" id="settingShowProcessed">
                                    <label for="settingShowProcessed">Afficher les fichiers deja traites</label>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-primary btn-full" id="btnSaveSettings">Sauvegarder les parametres</button>
                    </div>
                </div>

                <!-- History Page -->
                <div id="page-history" class="page hidden">
                    <div class="history-container">
                        <div class="history-header">
                            <h3>Fichiers traites</h3>
                            <button class="btn btn-danger" id="btnClearHistory">Effacer l'historique</button>
                        </div>
                        <div class="history-list" id="historyList"><div class="loading"><div class="spinner"></div>Chargement...</div></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <script>
        const TMDB_API_KEY = "49d8d37e45764e7c6794ed7dd2d896d4";
        const API_BASE = '';

        const state = {
            currentPage: 'files',
            currentPath: '/media',
            selectedFile: null,
            selectedIsDir: false,
            selectedMediaType: '',
            settings: {},
            workflowStep: 1,
            createdTorrentPath: null,
            createdNfoPath: null,
            mediaType: 'movie',
            releaseInfo: {},
            // Metadata (generic)
            metadataId: '',
            metadataData: null,
            // TMDB (films/series)
            tmdbId: '',
            tmdbData: null,
            // Google Books (ebooks)
            bookId: '',
            bookData: null,
            // Steam (games)
            steamId: '',
            gameData: null,
            nfoContent: ''
        };

        // ============ PARSER ============
        function parseMediaInfo(nfo) {
            const info = {};
            if (nfo.match(/Format\s*:\s*Matroska/i)) info.container = 'MKV';
            else if (nfo.match(/Format\s*:\s*MPEG-4/i)) info.container = 'MP4';

            const heightMatch = nfo.match(/Height\s*:\s*([\d\s]+)/);
            if (heightMatch) {
                const h = parseInt(heightMatch[1].replace(/\s/g, ''), 10);
                if (h >= 2100) info.resolution = '2160p';
                else if (h >= 1000) info.resolution = '1080p';
                else if (h >= 700) info.resolution = '720p';
                else info.resolution = '480p';
            }

            if (nfo.match(/Format\s*:\s*HEVC/i) || nfo.match(/Writing library\s*:\s*x265/i)) info.codec = 'x265';
            else if (nfo.match(/Format\s*:\s*AVC/i) || nfo.match(/Writing library\s*:\s*x264/i)) info.codec = 'x264';

            if (nfo.match(/Format\s*:\s*E-AC-3/i)) info.audio = 'EAC3';
            else if (nfo.match(/Format\s*:\s*AC-3/i)) info.audio = 'AC3';
            else if (nfo.match(/Format\s*:\s*DTS-HD/i)) info.audio = 'DTS-HD';
            else if (nfo.match(/Format\s*:\s*DTS/i)) info.audio = 'DTS';
            else if (nfo.match(/Format\s*:\s*TrueHD/i)) info.audio = 'TrueHD';
            else if (nfo.match(/Format\s*:\s*AAC/i)) info.audio = 'AAC';

            const channelMatches = [...nfo.matchAll(/Channel\(s\)\s*:\s*(\d+)/g)];
            if (channelMatches.length > 0) {
                const maxCh = Math.max(...channelMatches.map(m => parseInt(m[1], 10)));
                if (maxCh >= 8) info.audioChannels = '7.1';
                else if (maxCh >= 6) info.audioChannels = '5.1';
                else if (maxCh >= 2) info.audioChannels = '2.0';
            }

            const audioLangs = new Set();
            const subLangs = new Set();
            const sections = nfo.split(/(?:\r?\n){2,}/);
            let frenchAudio = false, nonFrenchAudio = false;

            for (const s of sections) {
                const audioHeader = s.match(/^Audio\s*(?:#\d+)?/im);
                const textHeader = s.match(/^(?:Text|Subtitle)\s*(?:#\d+)?/im);
                const hasAudioProps = s.includes('Channel(s)') && s.includes('Sampling rate');

                if (audioHeader || (!textHeader && hasAudioProps)) {
                    const langMatch = s.match(/Language\s*:\s*([^\r\n]+)/i);
                    if (langMatch) {
                        const lang = langMatch[1].trim();
                        audioLangs.add(lang);
                        const lowerLang = lang.toLowerCase();
                        if (lowerLang.includes('french') || lowerLang.includes('français')) frenchAudio = true;
                        else nonFrenchAudio = true;
                    }
                } else if (textHeader) {
                    const langMatch = s.match(/Language\s*:\s*([^\r\n]+)/i);
                    if (langMatch) subLangs.add(langMatch[1].trim());
                }
            }

            if (audioLangs.size > 0) info.audioLanguages = Array.from(audioLangs);
            if (subLangs.size > 0) info.subtitleLanguages = Array.from(subLangs);
            if (frenchAudio && nonFrenchAudio) info.language = 'MULTi';
            else if (frenchAudio) info.language = 'FRENCH';

            const hdr = [];
            if (nfo.includes('HDR10+')) hdr.push('HDR10+');
            else if (nfo.includes('HDR10') || nfo.match(/SMPTE ST 2086/)) hdr.push('HDR10');
            if (nfo.includes('Dolby Vision')) hdr.push('DV');
            if (hdr.length > 0) info.hdr = hdr;

            return info;
        }

        function parseReleaseName(name, nfoContent = '') {
            const info = {};
            let cleanName = name.trim();

            const groupMatch = cleanName.match(/-([a-zA-Z0-9\[\]]+)$/);
            if (groupMatch) info.releaseGroup = groupMatch[1];

            const patterns = {
                year: /\b(19|20)\d{2}\b/g,
                season: /\b(?:S|Season)\s?(\d{1,2})\b|\b(Complete|Integrale)\b/gi,
                episode: /\b(?:E|Episode)\s?(\d{1,3})\b/gi,
                seasonEpisode: /\bS(\d{1,2})E(\d{1,3})\b/gi,
                source: /\b(Bluray|BluRay|BDRip|BRRip|WEBRip|WebRip|WEB-DL|WEBDL|WEB|HDTV|DVDRip)\b/gi,
                ebookFormat: /\.(epub|pdf|mobi|azw3?|cbr|cbz)$/i
            };

            let firstTagIndex = cleanName.length;

            // Détecter le format ebook depuis l'extension
            const ebookMatch = patterns.ebookFormat.exec(cleanName);
            if (ebookMatch) {
                info.container = ebookMatch[1].toUpperCase();
                // Retirer l'extension pour le parsing du titre
                cleanName = cleanName.replace(patterns.ebookFormat, '');
            }

            const yearMatch = patterns.year.exec(cleanName);
            if (yearMatch) { info.year = yearMatch[0]; if (yearMatch.index < firstTagIndex) firstTagIndex = yearMatch.index; }

            patterns.seasonEpisode.lastIndex = 0;
            const sxeMatch = patterns.seasonEpisode.exec(cleanName);
            if (sxeMatch) {
                info.season = "S" + sxeMatch[1].padStart(2, '0');
                info.episode = "E" + sxeMatch[2].padStart(2, '0');
                if (sxeMatch.index < firstTagIndex) firstTagIndex = sxeMatch.index;
            } else {
                patterns.season.lastIndex = 0;
                const seasonMatch = patterns.season.exec(cleanName);
                if (seasonMatch) {
                    info.season = seasonMatch[2] ? seasonMatch[2].toUpperCase() : "S" + seasonMatch[1].padStart(2, '0');
                    if (seasonMatch.index < firstTagIndex) firstTagIndex = seasonMatch.index;
                }
                patterns.episode.lastIndex = 0;
                const epMatch = patterns.episode.exec(cleanName);
                if (epMatch) { info.episode = "E" + epMatch[1].padStart(2, '0'); if (epMatch.index < firstTagIndex) firstTagIndex = epMatch.index; }
            }

            patterns.source.lastIndex = 0;
            const sourceMatch = patterns.source.exec(cleanName);
            if (sourceMatch) { info.source = sourceMatch[0]; if (sourceMatch.index < firstTagIndex) firstTagIndex = sourceMatch.index; }

            let potentialTitle = cleanName.substring(0, firstTagIndex).replace(/\./g, ' ').replace(/_/g, ' ').replace(/[-()]+$/, '').trim();
            if (potentialTitle) info.title = potentialTitle;

            if (nfoContent) {
                const nfoInfo = parseMediaInfo(nfoContent);
                Object.assign(info, nfoInfo);
            }

            return info;
        }

        // ============ PRESENTATION ============
        async function generatePresentation(data) {
            const { tmdbId, mediaType, releaseInfo, nfoContent, totalSize } = data;

            // Pour les ebooks, utiliser Google Books
            if (mediaType === 'ebook') {
                return generateEbookPresentation(data);
            }

            // Pour les jeux, utiliser Steam
            if (mediaType === 'game') {
                return generateGamePresentation(data);
            }

            const type = (mediaType === 'movie') ? 'movie' : 'tv';
            let tmdbData = {};

            try {
                const res = await fetch(`https://api.themoviedb.org/3/${type}/${tmdbId}?api_key=${TMDB_API_KEY}&language=fr-FR`);
                tmdbData = await res.json();
            } catch (e) { console.error("TMDB fetch error:", e); }

            const title = tmdbData.title || tmdbData.name || releaseInfo.title || "Unknown Title";
            const year = (tmdbData.release_date || tmdbData.first_air_date || "").substring(0, 4) || releaseInfo.year || "";
            const posterUrl = tmdbData.poster_path ? `https://image.tmdb.org/t/p/w500${tmdbData.poster_path}` : "";
            const genres = (tmdbData.genres || []).map(g => g.name).join(", ") || "Non spécifié";
            const score = tmdbData.vote_average ? `${tmdbData.vote_average.toFixed(3)}/10` : "N/A";
            const overview = tmdbData.overview || "Aucune description disponible.";

            let size = totalSize || "Variable";
            if (!totalSize) {
                const sizeMatch = nfoContent.match(/File\s*size\s*:\s*([0-9.]+\s*[KMGT]?i?B)/i);
                if (sizeMatch) size = sizeMatch[1];
            }

            // Récupérer toutes les langues audio
            let audioLangs = "Non spécifié";
            if (releaseInfo.audioLanguages && releaseInfo.audioLanguages.length > 0) {
                audioLangs = releaseInfo.audioLanguages.join(", ");
            } else if (releaseInfo.language) {
                audioLangs = releaseInfo.language;
            }

            // Récupérer tous les sous-titres
            let subs = "Aucun";
            if (releaseInfo.subtitleLanguages && releaseInfo.subtitleLanguages.length > 0) {
                subs = releaseInfo.subtitleLanguages.join(", ");
            }

            const resolution = releaseInfo.resolution || "Non spécifié";
            const container = releaseInfo.container || "MKV";
            const video = releaseInfo.codec || "Non spécifié";
            const audio = releaseInfo.audio || "Non spécifié";

            return `[center]
[img]${posterUrl}[/img]

[size=6][color=#eab308][b]${title} (${year})[/b][/color][/size]

[b]Note :[/b] ${score}
[b]Genre :[/b] ${genres}

[quote]${overview}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Qualité :[/b] ${resolution}
[b]Format :[/b] ${container}
[b]Codec Vidéo :[/b] ${video}
[b]Codec Audio :[/b] ${audio}
[b]Langues :[/b] ${audioLangs}
[b]Sous-titres :[/b] ${subs}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        function generateEbookPresentation(data) {
            const { releaseInfo, totalSize } = data;
            const bookData = state.bookData || {};

            const title = bookData.title || releaseInfo.title || "Titre inconnu";
            const authors = (bookData.authors || []).join(", ") || "Auteur inconnu";
            const year = (bookData.publishedDate || "").substring(0, 4) || releaseInfo.year || "";
            const description = bookData.description || "Aucune description disponible.";
            const categories = (bookData.categories || []).join(", ") || "Non spécifié";
            const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || "";
            const pageCount = bookData.pageCount || "Non spécifié";
            const publisher = bookData.publisher || "Non spécifié";

            // Détecter le format depuis le nom du fichier ou releaseInfo
            let format = "EPUB";
            if (releaseInfo.container) {
                format = releaseInfo.container.toUpperCase();
            }

            let size = totalSize || "Variable";

            // Langue
            let language = bookData.language || "Non spécifié";
            if (language === "fr") language = "Français";
            else if (language === "en") language = "Anglais";

            return `[center]
${thumbnail ? `[img]${thumbnail}[/img]` : ''}

[size=6][color=#eab308][b]${title}${year ? ' (' + year + ')' : ''}[/b][/color][/size]

[b]Auteur :[/b] ${authors}
[b]Genre :[/b] ${categories}

[quote]${description.replace(/<[^>]*>/g, '')}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Editeur :[/b] ${publisher}
[b]Pages :[/b] ${pageCount}
[b]Format :[/b] ${format}
[b]Langue :[/b] ${language}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        function generateGamePresentation(data) {
            const { releaseInfo, totalSize } = data;
            const gameData = state.gameData || {};

            const title = gameData.name || releaseInfo.title || "Titre inconnu";
            const description = gameData.short_description || gameData.detailed_description || "Aucune description disponible.";
            const genres = (gameData.genres || []).map(g => g.description).join(", ") || "Non spécifié";
            const releaseDate = gameData.release_date?.date || releaseInfo.year || "Non spécifié";
            const developers = (gameData.developers || []).join(", ") || "Non spécifié";
            const publishers = (gameData.publishers || []).join(", ") || "Non spécifié";
            const headerImage = gameData.header_image || "";
            const metacritic = gameData.metacritic?.score ? `${gameData.metacritic.score}/100` : "N/A";

            let size = totalSize || "Variable";

            // Langues supportées
            let languages = "Non spécifié";
            if (gameData.supported_languages) {
                // Nettoyer le HTML des langues
                languages = gameData.supported_languages.replace(/<[^>]*>/g, '').substring(0, 100);
                if (gameData.supported_languages.length > 100) languages += '...';
            }

            return `[center]
${headerImage ? `[img]${headerImage}[/img]` : ''}

[size=6][color=#eab308][b]${title}[/b][/color][/size]

[b]Date de sortie :[/b] ${releaseDate}
[b]Genre :[/b] ${genres}
[b]Note Metacritic :[/b] ${metacritic}

[quote]${description.replace(/<[^>]*>/g, '')}[/quote]

[color=#eab308][b]--- DÉTAILS ---[/b][/color]

[b]Developpeur :[/b] ${developers}
[b]Editeur :[/b] ${publishers}
[b]Langues :[/b] ${languages}
[b]Taille :[/b] ${size}


[i]Généré par AATM[/i]
[/center]`;
        }

        // ============ UI FUNCTIONS ============
        document.addEventListener('DOMContentLoaded', () => {
            initNavigation();
            loadSettings();
            checkApiStatus();
            setInterval(checkApiStatus, 30000);

            document.getElementById('btnStep1Next').addEventListener('click', () => goToStep(2));
            document.getElementById('btnStep2Next').addEventListener('click', () => goToStep(3));
            document.getElementById('btnMetadataSearch').addEventListener('click', searchMetadata);
            document.getElementById('metadataQuery').addEventListener('keydown', e => { if (e.key === 'Enter') searchMetadata(); });
            document.getElementById('btnCreateTorrent').addEventListener('click', createTorrent);
            document.getElementById('btnFinish').addEventListener('click', finishWorkflow);
            document.getElementById('btnSaveSettings').addEventListener('click', saveSettings);
            document.getElementById('btnClearHistory').addEventListener('click', clearHistory);
            document.getElementById('btnCreateFromFolder').addEventListener('click', createTorrentFromCurrentFolder);

            document.querySelectorAll('.media-type-btn').forEach(btn => {
                btn.addEventListener('click', () => selectMediaType(btn.dataset.type));
            });
        });

        function initNavigation() {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', () => navigateTo(item.dataset.page));
            });
        }

        function navigateTo(page) {
            state.currentPage = page;
            document.querySelectorAll('.nav-item').forEach(item => item.classList.toggle('active', item.dataset.page === page));
            document.querySelectorAll('.page').forEach(p => p.classList.add('hidden'));
            document.getElementById(`page-${page}`).classList.remove('hidden');

            const titles = { files: 'Explorateur de fichiers', create: 'Creer un torrent', settings: 'Parametres', history: 'Historique' };
            document.getElementById('pageTitle').textContent = titles[page];

            if (page === 'files') loadFiles(state.currentPath);
            else if (page === 'settings') loadSettingsForm();
            else if (page === 'history') loadHistory();
            else if (page === 'create') updateWorkflowUI();
        }

        async function checkApiStatus() {
            try {
                const res = await fetch(`${API_BASE}/health`);
                document.getElementById('statusIndicator').className = res.ok ? 'status-indicator online' : 'status-indicator offline';
                document.getElementById('statusText').textContent = res.ok ? 'API en ligne' : 'API hors ligne';
            } catch (e) {
                document.getElementById('statusIndicator').className = 'status-indicator offline';
                document.getElementById('statusText').textContent = 'API hors ligne';
            }
        }

        async function loadFiles(path) {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';
            try {
                const res = await fetch(`${API_BASE}/api/files?path=${encodeURIComponent(path)}`);
                const files = await res.json();
                state.currentPath = path;
                updateBreadcrumb(path);
                renderFiles(files);
            } catch (e) {
                fileList.innerHTML = `<div class="empty-state"><p>Erreur: ${e.message}</p></div>`;
            }
        }

        function updateBreadcrumb(path) {
            const breadcrumb = document.getElementById('breadcrumb');
            const parts = path.split('/').filter(p => p);
            let html = '<span class="breadcrumb-item" onclick="loadFiles(\'/\')">~</span>';
            let currentPath = '';
            parts.forEach((part, i) => {
                currentPath += '/' + part;
                html += `<span class="breadcrumb-separator">/</span>`;
                html += i === parts.length - 1
                    ? `<span class="breadcrumb-item current">${part}</span>`
                    : `<span class="breadcrumb-item" onclick="loadFiles('${currentPath}')">${part}</span>`;
            });
            breadcrumb.innerHTML = html;
        }

        function renderFiles(files) {
            const fileList = document.getElementById('fileList');
            if (!files || files.length === 0) { fileList.innerHTML = '<div class="empty-state"><p>Aucun fichier media trouve</p></div>'; return; }

            let filteredFiles = state.settings.showProcessed ? files : files.filter(f => !f.isProcessed);
            filteredFiles.sort((a, b) => { if (a.isDir && !b.isDir) return -1; if (!a.isDir && b.isDir) return 1; return a.name.localeCompare(b.name); });

            const getFileIcon = (file) => {
                if (file.isDir) return '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>';
                if (file.mediaType === 'ebook') return '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>';
                if (file.mediaType === 'game') return '<rect x="2" y="6" width="20" height="12" rx="2"/><line x1="6" y1="12" x2="10" y2="12"/><line x1="8" y1="10" x2="8" y2="14"/><circle cx="17" cy="10" r="1"/><circle cx="15" cy="13" r="1"/>';
                return '<polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>';
            };

            const getFileClass = (file) => {
                if (file.isDir) return 'folder';
                if (file.mediaType === 'ebook') return 'ebook';
                if (file.mediaType === 'game') return 'game';
                return 'video';
            };

            fileList.innerHTML = filteredFiles.map(file => `
                <div class="file-item ${file.isProcessed ? 'processed' : ''}" data-name="${file.name}" data-isdir="${file.isDir}" data-mediatype="${file.mediaType || ''}" onclick="selectFile('${file.name.replace(/'/g, "\\'")}', ${file.isDir}, '${file.mediaType || ''}')">
                    <svg class="file-icon ${getFileClass(file)}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        ${getFileIcon(file)}
                    </svg>
                    <span class="file-name">${file.name}</span>
                    ${file.isProcessed ? '<span class="processed-badge">Traite</span>' : ''}
                    <span class="file-size">${file.isDir ? 'Dossier' : formatSize(file.size)}</span>
                </div>
            `).join('');
        }

        async function selectFile(name, isDir, mediaType = '') {
            const fullPath = state.currentPath + '/' + name;
            document.querySelectorAll('.file-item').forEach(el => el.classList.toggle('selected', el.dataset.name === name));

            // Pour les dossiers, naviguer dedans
            if (isDir) { loadFiles(fullPath); state.selectedFile = null; return; }

            state.selectedFile = fullPath;
            state.selectedIsDir = isDir;
            state.selectedMediaType = mediaType;
            document.getElementById('detailsTitle').textContent = name;
            document.getElementById('fileActions').style.display = 'flex';

            const detailsContent = document.getElementById('detailsContent');
            detailsContent.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';

            try {
                // Pour les ebooks et jeux, pas de MediaInfo
                if (mediaType === 'ebook' || mediaType === 'game') {
                    const sizeRes = await fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(fullPath)}`);
                    const sizeData = await sizeRes.json();
                    const typeLabel = mediaType === 'ebook' ? 'E-book' : 'Jeu video';
                    detailsContent.innerHTML = `
                        <div class="detail-section">
                            <h4>Informations</h4>
                            <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${fullPath}</span></div>
                            <div class="detail-row"><span class="detail-label">Taille</span><span class="detail-value">${sizeData.size}</span></div>
                            <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value">${typeLabel}</span></div>
                        </div>
                    `;
                } else {
                    const [sizeRes, mediaRes] = await Promise.all([
                        fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(fullPath)}`),
                        fetch(`${API_BASE}/api/mediainfo?path=${encodeURIComponent(fullPath)}`)
                    ]);
                    const sizeData = await sizeRes.json();
                    const mediaData = await mediaRes.json();

                    detailsContent.innerHTML = `
                        <div class="detail-section">
                            <h4>Informations</h4>
                            <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${fullPath}</span></div>
                            <div class="detail-row"><span class="detail-label">Taille</span><span class="detail-value">${sizeData.size}</span></div>
                        </div>
                        <div class="detail-section">
                            <h4>MediaInfo</h4>
                            <div class="mediainfo-output">${escapeHtml(mediaData.mediainfo)}</div>
                        </div>
                    `;
                }
            } catch (e) {
                detailsContent.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }

            document.getElementById('btnStartWorkflow').onclick = () => startWorkflow(fullPath, name, mediaType);
        }

        function startWorkflow(path, name, mediaType = '') {
            state.selectedFile = path;
            state.workflowStep = 1;
            state.releaseInfo = parseReleaseName(name);
            state.metadataId = '';
            state.metadataData = null;
            state.tmdbId = '';
            state.tmdbData = null;
            state.bookId = '';
            state.bookData = null;
            state.steamId = '';
            state.gameData = null;

            // Auto-sélectionner le type de média si détecté
            if (mediaType === 'ebook') {
                selectMediaType('ebook');
            } else if (mediaType === 'game') {
                selectMediaType('game');
            } else {
                selectMediaType('movie'); // Par défaut
            }

            document.getElementById('selectedSource').innerHTML = `
                <div class="alert alert-success"><strong>Source:</strong> ${name}</div>
                <div class="detail-row"><span class="detail-label">Chemin</span><span class="detail-value" style="word-break:break-all;font-size:0.85rem;">${path}</span></div>
            `;

            document.getElementById('torrentName').value = name.replace(/\.[^/.]+$/, '');
            document.getElementById('metadataQuery').value = state.releaseInfo.title || '';

            updateReleaseTags();
            document.getElementById('btnStep1Next').disabled = false;
            navigateTo('create');
        }

        function createTorrentFromCurrentFolder() {
            const path = state.currentPath;
            const name = path.split('/').pop() || 'dossier';

            // Lancer le workflow avec le dossier courant
            startWorkflow(path, name, '');
        }

        function selectMediaType(type) {
            state.mediaType = type;
            document.querySelectorAll('.media-type-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.type === type));
        }

        function updateReleaseTags() {
            const info = state.releaseInfo;
            const tags = [];
            if (info.year) tags.push(`<span class="tag year">${info.year}</span>`);
            if (info.resolution) tags.push(`<span class="tag resolution">${info.resolution}</span>`);
            if (info.source) tags.push(`<span class="tag source">${info.source}</span>`);
            if (info.codec) tags.push(`<span class="tag codec">${info.codec}</span>`);
            if (info.audio) tags.push(`<span class="tag audio">${info.audio}</span>`);
            if (info.audioChannels) tags.push(`<span class="tag audio">${info.audioChannels}</span>`);
            if (info.language) tags.push(`<span class="tag language">${info.language}</span>`);
            if (info.hdr) info.hdr.forEach(h => tags.push(`<span class="tag hdr">${h}</span>`));
            if (info.releaseGroup) tags.push(`<span class="tag group">-${info.releaseGroup}</span>`);
            if (info.audioLanguages) info.audioLanguages.forEach(l => tags.push(`<span class="tag language">${l}</span>`));
            document.getElementById('releaseTags').innerHTML = tags.length > 0 ? tags.join('') : '-';
        }

        function updateWorkflowUI() {
            document.querySelectorAll('.workflow-step').forEach(step => {
                const stepNum = parseInt(step.dataset.step);
                step.classList.remove('active', 'completed');
                step.style.display = '';

                if (stepNum === state.workflowStep) step.classList.add('active');
                else if (stepNum < state.workflowStep) step.classList.add('completed');
            });
            for (let i = 1; i <= 5; i++) document.getElementById(`step-${i}`).classList.toggle('hidden', i !== state.workflowStep);

            // Mettre à jour le label de l'étape 2 selon le type de média
            const step2Label = document.querySelector('.workflow-step[data-step="2"] .step-label');
            if (step2Label) {
                if (state.mediaType === 'ebook') step2Label.textContent = 'Google Books';
                else if (state.mediaType === 'game') step2Label.textContent = 'Steam';
                else step2Label.textContent = 'TMDB';
            }
        }

        async function goToStep(step) {
            state.workflowStep = step;
            updateWorkflowUI();

            if (step === 2) {
                // Configurer l'étape 2 selon le type de média
                const titleEl = document.getElementById('step2Title');
                const labelEl = document.getElementById('step2Label');
                const queryEl = document.getElementById('metadataQuery');
                const resultsEl = document.getElementById('metadataResults');
                const selectedEl = document.getElementById('metadataSelected');

                resultsEl.classList.add('hidden');
                selectedEl.classList.add('hidden');

                if (state.mediaType === 'ebook') {
                    titleEl.textContent = 'Identification Google Books';
                    labelEl.textContent = 'Rechercher sur Google Books';
                    queryEl.placeholder = 'Titre du livre ou auteur...';
                } else if (state.mediaType === 'game') {
                    titleEl.textContent = 'Identification Steam';
                    labelEl.textContent = 'Rechercher sur Steam';
                    queryEl.placeholder = 'Nom du jeu...';
                } else {
                    titleEl.textContent = 'Identification TMDB';
                    labelEl.textContent = 'Rechercher sur TMDB';
                    queryEl.placeholder = 'Titre du film ou serie...';
                }

                // Auto-search si query remplie
                if (queryEl.value && !state.metadataId) searchMetadata();
            } else if (step === 3) {
                const mediaInfoEl = document.getElementById('workflowMediainfo');
                const nfoEl = document.getElementById('nfoContent');

                // Pour les ebooks et jeux, pas de MediaInfo
                if (state.mediaType === 'ebook' || state.mediaType === 'game') {
                    mediaInfoEl.textContent = 'MediaInfo non disponible pour ce type de fichier';
                    nfoEl.value = '';
                    state.nfoContent = '';
                } else {
                    mediaInfoEl.textContent = 'Chargement...';
                    try {
                        const res = await fetch(`${API_BASE}/api/mediainfo?path=${encodeURIComponent(state.selectedFile)}`);
                        const data = await res.json();
                        mediaInfoEl.textContent = data.mediainfo;
                        nfoEl.value = data.mediainfo;
                        state.nfoContent = data.mediainfo;

                        // Re-parse with NFO content for better tag detection
                        const name = state.selectedFile.split('/').pop();
                        state.releaseInfo = parseReleaseName(name, data.mediainfo);
                        updateReleaseTags();
                    } catch (e) { mediaInfoEl.textContent = 'Erreur: ' + e.message; }
                }
            } else if (step === 4) {
                if (state.settings.torrentTrackers) document.getElementById('trackersInput').value = state.settings.torrentTrackers;
                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.add('hidden');
            } else if (step === 5) {
                document.getElementById('createdTorrentPath').textContent = state.createdTorrentPath || '-';
                document.getElementById('createdNfoPath').textContent = state.createdNfoPath || '-';
            }
        }

        // ============ METADATA SEARCH (TMDB / Google Books / Steam) ============
        async function searchMetadata() {
            const query = document.getElementById('metadataQuery').value;
            if (!query) return;

            if (state.mediaType === 'ebook') {
                await searchGoogleBooks(query);
            } else if (state.mediaType === 'game') {
                await searchSteam(query);
            } else {
                await searchTmdb(query);
            }
        }

        async function searchTmdb(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche TMDB...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            const type = state.mediaType === 'movie' ? 'movie' : 'tv';
            try {
                const res = await fetch(`https://api.themoviedb.org/3/search/${type}?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}&language=fr-FR`);
                const data = await res.json();

                if (!data.results || data.results.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.results.slice(0, 10).map(item => `
                    <div class="tmdb-item" onclick="selectTmdbItem(${item.id})">
                        <img src="${item.poster_path ? 'https://image.tmdb.org/t/p/w92' + item.poster_path : ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-item-info">
                            <div class="tmdb-item-title">${item.title || item.name}</div>
                            <div class="tmdb-item-year">${(item.release_date || item.first_air_date || '').substring(0, 4)} - ID: ${item.id}</div>
                            <div class="tmdb-item-overview">${item.overview || ''}</div>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }
        }

        async function selectTmdbItem(id) {
            state.metadataId = id.toString();
            state.tmdbId = id.toString();
            const type = state.mediaType === 'movie' ? 'movie' : 'tv';

            try {
                const res = await fetch(`https://api.themoviedb.org/3/${type}/${id}?api_key=${TMDB_API_KEY}&language=fr-FR`);
                state.metadataData = await res.json();
                state.tmdbData = state.metadataData;

                if (state.metadataData.genres) state.releaseInfo.genres = state.metadataData.genres.map(g => g.name);

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');
                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${state.metadataData.poster_path ? 'https://image.tmdb.org/t/p/w154' + state.metadataData.poster_path : ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${state.metadataData.title || state.metadataData.name}</div>
                            <div class="tmdb-selected-meta">${(state.metadataData.release_date || state.metadataData.first_air_date || '').substring(0, 4)} - ${(state.metadataData.genres || []).map(g => g.name).join(', ')}</div>
                            <div class="tmdb-selected-overview">${state.metadataData.overview || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur TMDB: ' + e.message, 'error');
            }
        }

        // ============ GOOGLE BOOKS API ============
        async function searchGoogleBooks(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche Google Books...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            try {
                const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=10&langRestrict=fr`);
                const data = await res.json();

                if (!data.items || data.items.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.items.map(item => {
                    const info = item.volumeInfo || {};
                    const thumbnail = info.imageLinks?.thumbnail || '';
                    const authors = (info.authors || []).join(', ');
                    const year = (info.publishedDate || '').substring(0, 4);
                    return `
                        <div class="tmdb-item" onclick="selectGoogleBook('${item.id}')">
                            <img src="${thumbnail}" alt="" onerror="this.style.display='none'">
                            <div class="tmdb-item-info">
                                <div class="tmdb-item-title">${info.title || 'Sans titre'}</div>
                                <div class="tmdb-item-year">${authors}${year ? ' - ' + year : ''}</div>
                                <div class="tmdb-item-overview">${info.description || ''}</div>
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
            }
        }

        async function selectGoogleBook(id) {
            state.metadataId = id;
            state.bookId = id;

            try {
                const res = await fetch(`https://www.googleapis.com/books/v1/volumes/${id}`);
                const data = await res.json();
                const info = data.volumeInfo || {};
                state.metadataData = info;
                state.bookData = info;

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');

                const thumbnail = info.imageLinks?.thumbnail || info.imageLinks?.smallThumbnail || '';
                const authors = (info.authors || []).join(', ');
                const year = (info.publishedDate || '').substring(0, 4);
                const categories = (info.categories || []).join(', ');

                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${thumbnail}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${info.title || 'Sans titre'}</div>
                            <div class="tmdb-selected-meta">${authors}${year ? ' (' + year + ')' : ''}${categories ? ' - ' + categories : ''}</div>
                            <div class="tmdb-selected-overview">${info.description || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur Google Books: ' + e.message, 'error');
            }
        }

        // ============ STEAM API (via proxy backend) ============
        async function searchSteam(query) {
            const resultsEl = document.getElementById('metadataResults');
            const selectedEl = document.getElementById('metadataSelected');
            resultsEl.innerHTML = '<div class="loading"><div class="spinner"></div>Recherche Steam...</div>';
            resultsEl.classList.remove('hidden');
            selectedEl.classList.add('hidden');

            try {
                const res = await fetch(`${API_BASE}/api/steam/search?q=${encodeURIComponent(query)}`);
                const data = await res.json();

                if (!data.items || data.items.length === 0) {
                    resultsEl.innerHTML = '<div class="empty-state"><p>Aucun resultat</p></div>';
                    return;
                }

                resultsEl.innerHTML = data.items.slice(0, 10).map(item => `
                    <div class="tmdb-item" onclick="selectSteamGame(${item.id})">
                        <img src="${item.tiny_image || ''}" alt="" onerror="this.style.display='none'">
                        <div class="tmdb-item-info">
                            <div class="tmdb-item-title">${item.name}</div>
                            <div class="tmdb-item-year">Steam ID: ${item.id}</div>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                resultsEl.innerHTML = `<div class="alert alert-danger">Erreur Steam: ${e.message}</div>`;
            }
        }

        async function selectSteamGame(id) {
            state.metadataId = id.toString();
            state.steamId = id.toString();

            try {
                const res = await fetch(`${API_BASE}/api/steam/details?appid=${id}`);
                const data = await res.json();
                const gameData = data[id]?.data;

                if (!gameData) {
                    showToast('Impossible de charger les details du jeu', 'error');
                    return;
                }

                state.metadataData = gameData;
                state.gameData = gameData;

                document.getElementById('metadataResults').classList.add('hidden');
                const selectedEl = document.getElementById('metadataSelected');
                selectedEl.classList.remove('hidden');

                const genres = (gameData.genres || []).map(g => g.description).join(', ');
                const releaseDate = gameData.release_date?.date || '';

                selectedEl.innerHTML = `
                    <div class="tmdb-selected">
                        <img src="${gameData.header_image || ''}" alt="" style="width:200px;height:auto;" onerror="this.style.display='none'">
                        <div class="tmdb-selected-info">
                            <div class="tmdb-selected-title">${gameData.name}</div>
                            <div class="tmdb-selected-meta">${releaseDate}${genres ? ' - ' + genres : ''}</div>
                            <div class="tmdb-selected-overview">${gameData.short_description || ''}</div>
                        </div>
                    </div>
                `;

                document.getElementById('btnStep2Next').disabled = false;
            } catch (e) {
                showToast('Erreur Steam: ' + e.message, 'error');
            }
        }

        async function createTorrent() {
            const btn = document.getElementById('btnCreateTorrent');
            btn.disabled = true;
            document.getElementById('btnStep4Back').disabled = true;
            document.getElementById('creationProgress').classList.remove('hidden');

            const trackers = document.getElementById('trackersInput').value.split('\n').filter(t => t.trim());
            const isPrivate = document.getElementById('torrentPrivate').checked;
            state.nfoContent = document.getElementById('nfoContent').value;

            try {
                // Save NFO
                const nfoRes = await fetch(`${API_BASE}/api/nfo/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sourcePath: state.selectedFile, content: state.nfoContent })
                });
                if (!nfoRes.ok) throw new Error('Erreur sauvegarde NFO');
                const nfoData = await nfoRes.json();
                state.createdNfoPath = nfoData.nfoPath;

                // Create torrent
                const torrentRes = await fetch(`${API_BASE}/api/torrent/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sourcePath: state.selectedFile, trackers, comment: 'AATM', isPrivate })
                });
                if (!torrentRes.ok) throw new Error('Erreur creation torrent');
                const torrentData = await torrentRes.json();
                state.createdTorrentPath = torrentData.torrentPath;

                // Create hardlink if enabled
                let hardlinkPath = null;
                if (state.settings.enableHardlink && state.settings.hardlinkDirs && state.settings.hardlinkDirs.length > 0) {
                    try {
                        const hardlinkRes = await fetch(`${API_BASE}/api/hardlink/create`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                sourcePath: state.selectedFile,
                                hardlinkDirs: state.settings.hardlinkDirs
                            })
                        });
                        if (hardlinkRes.ok) {
                            const hardlinkData = await hardlinkRes.json();
                            hardlinkPath = hardlinkData.hardlinkPath;
                        }
                    } catch (hlErr) {
                        console.warn('Hardlink creation failed:', hlErr);
                    }
                }

                // Mark processed
                await fetch(`${API_BASE}/api/processed/mark`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: state.selectedFile })
                });

                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.remove('hidden');
                let successMsg = 'Torrent et NFO crees avec succes!';
                if (hardlinkPath) successMsg += `<br><small>Hardlink: ${hardlinkPath}</small>`;
                document.getElementById('creationResult').innerHTML = `<div class="alert alert-success">${successMsg}</div>`;
                showToast('Torrent cree!', 'success');
                setTimeout(() => goToStep(5), 1000);
            } catch (e) {
                document.getElementById('creationProgress').classList.add('hidden');
                document.getElementById('creationResult').classList.remove('hidden');
                document.getElementById('creationResult').innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
                btn.disabled = false;
                document.getElementById('btnStep4Back').disabled = false;
                showToast('Erreur: ' + e.message, 'error');
            }
        }

        async function uploadToQBittorrent() {
            const statusEl = document.getElementById('uploadStatus');
            statusEl.innerHTML = '<div class="loading"><div class="spinner"></div>Upload qBittorrent...</div>';
            try {
                const res = await fetch(`${API_BASE}/api/qbittorrent/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        torrentPath: state.createdTorrentPath,
                        qbitUrl: state.settings.qbitUrl || 'http://localhost:8081',
                        username: state.settings.qbitUsername || 'admin',
                        password: state.settings.qbitPassword || 'adminadmin'
                    })
                });
                if (!res.ok) throw new Error('Erreur upload qBittorrent');
                statusEl.innerHTML = '<div class="alert alert-success">Upload qBittorrent reussi!</div>';
                showToast('Upload qBittorrent OK!', 'success');
            } catch (e) {
                statusEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
                showToast('Erreur: ' + e.message, 'error');
            }
        }

        async function uploadToLaCale() {
            const statusEl = document.getElementById('uploadStatus');
            statusEl.innerHTML = '<div class="loading"><div class="spinner"></div>Generation de la description et upload...</div>';

            try {
                // Get total size if needed
                let totalSize = null;
                try {
                    const sizeRes = await fetch(`${API_BASE}/api/directory-size?path=${encodeURIComponent(state.selectedFile)}`);
                    const sizeData = await sizeRes.json();
                    totalSize = sizeData.size;
                } catch (e) {}

                // Generate description
                const description = await generatePresentation({
                    releaseInfo: state.releaseInfo,
                    tmdbId: state.tmdbId,
                    mediaType: state.mediaType,
                    nfoContent: state.nfoContent,
                    totalSize
                });

                const torrentName = document.getElementById('torrentName').value || state.selectedFile.split('/').pop();

                const res = await fetch(`${API_BASE}/api/lacale/upload`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        torrentPath: state.createdTorrentPath,
                        nfoPath: state.createdNfoPath,
                        title: torrentName,
                        description: description,
                        tmdbId: state.tmdbId,
                        mediaType: state.mediaType,
                        releaseInfo: state.releaseInfo,
                        passkey: state.settings.passkey,
                        email: state.settings.laCaleEmail,
                        password: state.settings.laCalePassword
                    })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(errText || 'Erreur upload La-Cale');
                }

                statusEl.innerHTML = '<div class="alert alert-success">Upload La-Cale reussi!</div>';
                showToast('Upload La-Cale OK!', 'success');
            } catch (e) {
                statusEl.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`;
                showToast('Erreur: ' + e.message, 'error');
            }
        }

        async function finishWorkflow() {
            const btn = document.getElementById('btnFinish');
            btn.disabled = true;
            btn.textContent = 'Upload en cours...';

            // Upload to La-Cale first
            await uploadToLaCale();

            // Reset state
            state.selectedFile = null;
            state.createdTorrentPath = null;
            state.createdNfoPath = null;
            state.workflowStep = 1;
            state.metadataId = '';
            state.metadataData = null;
            state.tmdbId = '';
            state.tmdbData = null;
            state.bookId = '';
            state.bookData = null;
            state.steamId = '';
            state.gameData = null;
            navigateTo('files');
            showToast('Workflow termine!', 'success');
        }

        async function loadSettings() {
            try {
                const res = await fetch(`${API_BASE}/api/settings`);
                if (res.ok) {
                    state.settings = await res.json();
                    if (!state.settings.rootPath) state.settings.rootPath = '/media';
                    state.currentPath = state.settings.rootPath;
                    loadFiles(state.currentPath);
                }
            } catch (e) { loadFiles('/media'); }
        }

        function loadSettingsForm() {
            document.getElementById('settingRootPath').value = state.settings.rootPath || '/media';
            document.getElementById('settingTrackers').value = state.settings.torrentTrackers || '';
            document.getElementById('settingQbitUrl').value = state.settings.qbitUrl || 'http://localhost:8081';
            document.getElementById('settingQbitUsername').value = state.settings.qbitUsername || 'admin';
            document.getElementById('settingQbitPassword').value = state.settings.qbitPassword || '';
            document.getElementById('settingLaCaleEmail').value = state.settings.laCaleEmail || '';
            document.getElementById('settingLaCalePassword').value = state.settings.laCalePassword || '';
            document.getElementById('settingLaCalePasskey').value = state.settings.passkey || '';
            document.getElementById('settingEnableHardlink').checked = state.settings.enableHardlink || false;
            document.getElementById('settingHardlinkDirs').value = (state.settings.hardlinkDirs || []).join('\n');
            document.getElementById('settingShowProcessed').checked = state.settings.showProcessed || false;
        }

        async function saveSettings() {
            const hardlinkDirsText = document.getElementById('settingHardlinkDirs').value;
            const hardlinkDirs = hardlinkDirsText.split('\n').map(s => s.trim()).filter(s => s !== '');

            const settings = {
                rootPath: document.getElementById('settingRootPath').value,
                torrentTrackers: document.getElementById('settingTrackers').value,
                qbitUrl: document.getElementById('settingQbitUrl').value,
                qbitUsername: document.getElementById('settingQbitUsername').value,
                qbitPassword: document.getElementById('settingQbitPassword').value,
                laCaleEmail: document.getElementById('settingLaCaleEmail').value,
                laCalePassword: document.getElementById('settingLaCalePassword').value,
                passkey: document.getElementById('settingLaCalePasskey').value,
                enableHardlink: document.getElementById('settingEnableHardlink').checked,
                hardlinkDirs: hardlinkDirs,
                showProcessed: document.getElementById('settingShowProcessed').checked
            };
            try {
                const res = await fetch(`${API_BASE}/api/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                if (!res.ok) throw new Error('Erreur sauvegarde');
                state.settings = settings;
                state.currentPath = settings.rootPath;
                showToast('Parametres sauvegardes!', 'success');
            } catch (e) { showToast('Erreur: ' + e.message, 'error'); }
        }

        async function loadHistory() {
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '<div class="loading"><div class="spinner"></div>Chargement...</div>';
            try {
                const res = await fetch(`${API_BASE}/api/processed`);
                const files = await res.json();
                historyList.innerHTML = (!files || files.length === 0)
                    ? '<div class="empty-state"><p>Aucun fichier traite</p></div>'
                    : files.map(file => `<div class="history-item"><span class="history-path">${file.path}</span><span style="color:var(--text-muted);font-size:0.8rem;margin-left:1rem;">${file.processedAt}</span></div>`).join('');
            } catch (e) { historyList.innerHTML = `<div class="alert alert-danger">Erreur: ${e.message}</div>`; }
        }

        async function clearHistory() {
            if (!confirm('Voulez-vous vraiment effacer tout l\'historique?')) return;
            try {
                await fetch(`${API_BASE}/api/processed`, { method: 'DELETE' });
                showToast('Historique efface!', 'success');
                loadHistory();
            } catch (e) { showToast('Erreur: ' + e.message, 'error'); }
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message, type = 'success') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;color:var(--${type === 'success' ? 'success-text' : 'danger-text'});">
                    ${type === 'success' ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>' : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'}
                </svg>
                <span>${message}</span>
            `;
            container.appendChild(toast);
            setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 300); }, 3000);
        }
    </script>
</body>
</html>
